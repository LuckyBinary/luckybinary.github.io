{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/bg/banner.jpeg","path":"img/bg/banner.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg/favicon.png","path":"img/bg/favicon.png","modified":1,"renderable":0},{"_id":"source/img/bg/post_banner.jpeg","path":"img/bg/post_banner.jpeg","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_10.png","path":"img/notes/2018-5-19_1_10.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_11.png","path":"img/notes/2018-5-19_1_11.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_12.png","path":"img/notes/2018-5-19_1_12.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_13.png","path":"img/notes/2018-5-19_1_13.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_14.png","path":"img/notes/2018-5-19_1_14.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_2.png","path":"img/notes/2018-5-19_1_2.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_3.png","path":"img/notes/2018-5-19_1_3.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_4.png","path":"img/notes/2018-5-19_1_4.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_5.png","path":"img/notes/2018-5-19_1_5.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_6.png","path":"img/notes/2018-5-19_1_6.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_7.png","path":"img/notes/2018-5-19_1_7.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_8.png","path":"img/notes/2018-5-19_1_8.png","modified":1,"renderable":0},{"_id":"source/img/notes/2018-5-19_1_9.png","path":"img/notes/2018-5-19_1_9.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_1.png","path":"img/notes/2020-3-27_1_1.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_10.png","path":"img/notes/2020-3-27_1_10.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_11.png","path":"img/notes/2020-3-27_1_11.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_12.png","path":"img/notes/2020-3-27_1_12.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_13.png","path":"img/notes/2020-3-27_1_13.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_14.png","path":"img/notes/2020-3-27_1_14.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_15.png","path":"img/notes/2020-3-27_1_15.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_16.png","path":"img/notes/2020-3-27_1_16.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_17.png","path":"img/notes/2020-3-27_1_17.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_18.png","path":"img/notes/2020-3-27_1_18.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_19.png","path":"img/notes/2020-3-27_1_19.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_2.png","path":"img/notes/2020-3-27_1_2.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_20.png","path":"img/notes/2020-3-27_1_20.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_21.png","path":"img/notes/2020-3-27_1_21.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_22.png","path":"img/notes/2020-3-27_1_22.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_23.png","path":"img/notes/2020-3-27_1_23.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_24.png","path":"img/notes/2020-3-27_1_24.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_25.png","path":"img/notes/2020-3-27_1_25.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_26.png","path":"img/notes/2020-3-27_1_26.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_27.png","path":"img/notes/2020-3-27_1_27.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_28.png","path":"img/notes/2020-3-27_1_28.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_29.png","path":"img/notes/2020-3-27_1_29.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_3.png","path":"img/notes/2020-3-27_1_3.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_30.png","path":"img/notes/2020-3-27_1_30.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_31.png","path":"img/notes/2020-3-27_1_31.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_32.png","path":"img/notes/2020-3-27_1_32.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_33.png","path":"img/notes/2020-3-27_1_33.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_34.png","path":"img/notes/2020-3-27_1_34.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_5.png","path":"img/notes/2020-3-27_1_5.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_6.png","path":"img/notes/2020-3-27_1_6.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_7.png","path":"img/notes/2020-3-27_1_7.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_8.png","path":"img/notes/2020-3-27_1_8.png","modified":1,"renderable":0},{"_id":"source/img/notes/2020-3-27_1_9.png","path":"img/notes/2020-3-27_1_9.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"42db1f1f80d4253c3ee5c1b4ac39165d6eef352f","modified":1626599840358},{"_id":"source/CNAME","hash":"73518e4c29bbf9766312b8c48fdaa190b124d427","modified":1620974247616},{"_id":"source/_posts/RESTful-API.md","hash":"7db1bcbc2dae8cb687a7433a152f502eb3e4be7c","modified":1621491649909},{"_id":"source/_posts/Git指南.md","hash":"56444e3d81b58cc53a0c72f755dbe529e5393605","modified":1626600975969},{"_id":"source/_posts/计算机网络.md","hash":"064e5d899698dc9305c7e943a6c623b981905c91","modified":1624434321671},{"_id":"source/img/bg/favicon.png","hash":"6c13328965ee7bca93c170bdfeec78d24cfa4d81","modified":1620970887898},{"_id":"source/img/notes/2018-5-19_1_10.png","hash":"ffdbca5565636d3419c489c9c48b863ccb323754","modified":1621410316758},{"_id":"source/img/notes/2018-5-19_1_11.png","hash":"2bb05158e27b591984e4170c2dbe6a200597caea","modified":1621410316770},{"_id":"source/img/notes/2018-5-19_1_13.png","hash":"2a0eb2c3689465e9c17d83c5b6655bcb9b35f62c","modified":1621410316794},{"_id":"source/img/notes/2018-5-19_1_14.png","hash":"092ccbc5bfa90ddd9dfddc74403d8ed0423ef657","modified":1621410316804},{"_id":"source/img/notes/2018-5-19_1_2.png","hash":"722e02cab418a52f32908011aa1bc3d4434f5141","modified":1621410316670},{"_id":"source/img/notes/2018-5-19_1_3.png","hash":"e90fb4539564d657520a2947a2bba61233a8fda8","modified":1621410316683},{"_id":"source/img/notes/2018-5-19_1_4.png","hash":"ed7a089471712369283e68f5e1374e397796ec85","modified":1621410316695},{"_id":"source/img/notes/2018-5-19_1_5.png","hash":"d5154aaad1f6d7a8a61910e75d0517fbac371b77","modified":1621410316704},{"_id":"source/img/notes/2018-5-19_1_6.png","hash":"ab103e3e61b294c46b84b17931e65f69dfb82be8","modified":1621410316716},{"_id":"source/img/notes/2018-5-19_1_7.png","hash":"74368fd3eafe6fac58959b205e2251622b08b9be","modified":1621410316728},{"_id":"source/img/notes/2020-3-27_1_1.png","hash":"bc12a10b29cdbab5978e3e96aab83fba9564801e","modified":1621075774196},{"_id":"source/img/notes/2020-3-27_1_13.png","hash":"027b464b744f86ccee96349db51cf677b84f005a","modified":1621075774295},{"_id":"source/img/notes/2020-3-27_1_10.png","hash":"7f44667c01b847654c81d7660ef789d85cba28aa","modified":1621075774270},{"_id":"source/img/notes/2020-3-27_1_12.png","hash":"0308420956c1e6e8bf40e9e0e1e3eabd59b9420f","modified":1621075774286},{"_id":"source/img/notes/2020-3-27_1_14.png","hash":"fd5275b53ffe344a848f361a7d46162e502b7e61","modified":1621075774302},{"_id":"source/img/notes/2020-3-27_1_15.png","hash":"47d8e335e0169add1860a2bdf0e5775b41c50211","modified":1621075774312},{"_id":"source/img/notes/2020-3-27_1_16.png","hash":"e7317b8cf79ffdbf63b0f69f8705d8c7e7e174ac","modified":1621075774319},{"_id":"source/img/notes/2020-3-27_1_17.png","hash":"4913fa075f6ead0ae854aed1aef9021c0fc1cc2f","modified":1621075774329},{"_id":"source/img/notes/2020-3-27_1_2.png","hash":"4da26f0c4a3990d09c8285139fb2791c96edfddb","modified":1621075774209},{"_id":"source/img/notes/2020-3-27_1_19.png","hash":"137adc794b54e3892726e5f6e2acd84db58a7bed","modified":1621075774350},{"_id":"source/img/notes/2020-3-27_1_18.png","hash":"976cabbb186ac7ffc73feb4202e2109fa730615d","modified":1621075774341},{"_id":"source/img/notes/2020-3-27_1_20.png","hash":"1fc4d6daa45b04cc85814996b92993264cc47282","modified":1621075774361},{"_id":"source/img/notes/2020-3-27_1_22.png","hash":"bbaac9f0e7d872aa3c134e154c2661596bb152c0","modified":1621075774384},{"_id":"source/img/notes/2020-3-27_1_23.png","hash":"bd450151385fce6f37f53927f8e69662433695fa","modified":1621075774396},{"_id":"source/img/notes/2020-3-27_1_24.png","hash":"caff0d99f64c60da989bcc6cb1ce5a1c11551f2b","modified":1621075774409},{"_id":"source/img/notes/2020-3-27_1_27.png","hash":"db99ebff1e1e98da4d3b3bfce6fb53b80af29bc1","modified":1621075774445},{"_id":"source/img/notes/2020-3-27_1_28.png","hash":"6508cb73ca9a25466319a3a6a243824d04a9198f","modified":1621075774455},{"_id":"source/img/notes/2020-3-27_1_29.png","hash":"23b0194ad6adeb94ddebb60faabdc5c01622e548","modified":1621075774468},{"_id":"source/img/notes/2020-3-27_1_30.png","hash":"6b70fbd50364af3b6e56e2c612ee66e286c42297","modified":1621075774494},{"_id":"source/img/notes/2020-3-27_1_31.png","hash":"dcaf412969518914853a7d3678758e6831689466","modified":1621075774517},{"_id":"source/img/notes/2020-3-27_1_3.png","hash":"b3d3a8bcc85bce87ba513fcf9a84c43e28fae659","modified":1621235750308},{"_id":"source/img/notes/2020-3-27_1_32.png","hash":"94f6cdefbdbbe68b7accd8125cbd9ba02aacb57d","modified":1621228835172},{"_id":"source/img/notes/2020-3-27_1_33.png","hash":"a32e4390b8b77affcf59e3ec1756fd848bba4fc6","modified":1621234264167},{"_id":"source/img/notes/2020-3-27_1_7.png","hash":"8a1d37fe63a19316bafb4cc60b609fd694a081bd","modified":1621075774247},{"_id":"source/img/notes/2020-3-27_1_5.png","hash":"d5c0dcd68a71b35bc7cdaf67e1bf40fff4ad879c","modified":1621075774232},{"_id":"source/img/notes/2020-3-27_1_8.png","hash":"42693874d3c5f87c73742513a224542543b6e418","modified":1621075774254},{"_id":"source/img/notes/2020-3-27_1_9.png","hash":"292e3427268633c898c8574f0b1b3b1732129241","modified":1621075774263},{"_id":"source/about/index.md","hash":"feee4dac2ef062c691f27d8ad6943afe0a3e9ecd","modified":1620977778469},{"_id":"source/img/notes/2018-5-19_1_8.png","hash":"ae47c09cbc458436f312c3523d7473bb44380d93","modified":1621410316737},{"_id":"source/img/notes/2018-5-19_1_9.png","hash":"4433aa83147852d8abaa5ac6183a23b39f44dce2","modified":1621410316749},{"_id":"source/img/bg/post_banner.jpeg","hash":"94c7e900160fd6db2fbc392cd331f19c4769836e","modified":1620983806216},{"_id":"source/img/notes/2018-5-19_1_12.png","hash":"41cc668b18654086e561eae25fd15d3bfb9768f0","modified":1621410316782},{"_id":"source/img/bg/banner.jpeg","hash":"6934adcdaf0e54e7908c5452ab72a54747dc2e48","modified":1620960530133},{"_id":"source/img/notes/2020-3-27_1_21.png","hash":"ad89f1aca9c13955fdf168848ed42206321cf34b","modified":1621075774371},{"_id":"source/img/notes/2020-3-27_1_25.png","hash":"9ab6e92faff995afb7e5a4f726799ab376a111ba","modified":1621075774419},{"_id":"source/img/notes/2020-3-27_1_26.png","hash":"deebf40e933f27cf702794f115f286cd6cc9a825","modified":1621075774432},{"_id":"source/img/notes/2020-3-27_1_11.png","hash":"8941af45cb26e2194d2a47ad2079207b7821c2db","modified":1621075774279},{"_id":"source/img/notes/2020-3-27_1_6.png","hash":"3f03d68d1f5d1d6eb2ebe5f2dd3f1100a85a8f85","modified":1624429733396},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"1da53e2a2e61da482d2bbef8aea3d61dca697725","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"a7c87a83becf7080bddd14e81a6f09ce8c3df109","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"11b11f4b2d8efc90549cbfa766e0d669bf158e2f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"523b9db3801ca892124502c17d72864457cc4b21","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6cbd88a2ef9dd2198d72ccc1899c4966ac5f49f9","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"a154785aef120988d29409847977f24069d3a3d5","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"9d6ff8772bf54d7458ae4e846e5a2d1f2921b8a7","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"19c6db0ccebc8f59fa4ef9567a066b33223eccd6","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"8723aa57f61134a2c1dc84cc7ea88ea366f4fda3","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"bccd7961fa146dd5f0d70f77e7ab94e9f58d5bd3","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"6ec30a9dd56341590af07f4227324f619025c109","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"cdcb607f1104543a42beda647f3c9cf0f3d11623","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"39e63b3e1502803c9e8ea0c44ea662a7bbe15744","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"248ecd01aead6e07ac1904a7b7c45395a922bcc7","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"245f49aad0e4124b52aa82d981281ad9c871f1f8","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"569642bb89610c3c0f1827b1b6dff90571ec4879","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"a2b4d8b1ce866c5dda350887c3fad6d3a5426f70","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"3e0fa1731b6e54dbcf52ccf8e200e83dc4549bfa","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"7d7444387e549e06a4a378706df92558de62e4e7","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"f7fd69496ffc156cc1c224fb8d26c46d5b437425","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"4701f49b3dc62939adff5cc11f6d21963df7f135","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d1aef2da328e10dadcd403eaea95d6f6e4665622","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"702cd88097274924971292c042ae4955999c3a4b","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"fb4502fc9204284f8b4e8dabde8477d478e826e5","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"1ff78b48faa3a7ea0b3a649a2632adc8cc65b79b","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"0b158c7e0cf630261271fce4a685698c5b14580a","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"ae5685ce20424d1c3c9b2cd983ed5f80a81b7002","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"497801aca43854e0bcb8092166752291a8e17c36","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"7d85b7466ac3c38a826c25418d8408fa561ec6da","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"6cbd241656c688fb37ca2627caf7969b7854de25","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"afe18734fc52e31fb7b6e0b5360aa936007ec22f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"d6f4ecb8a965ad86295f211081e7bb6c00af7737","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/local-search.ejs","hash":"c8b29cf71176a2f36b5b06a4befdbd405c42fbd6","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"a2d08e3b9f98b6371b2e64d664f079c99571494b","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ab71df2e56b60e8e193ff827e81704e5b358a977","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"26d29403d8ecb0b533e63bde3ca73b2c91f171ff","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"2366bd7cf64735a140d730c8efae83734cc36acf","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"ad7dcc8a060d94d3c44ca5e0788a24ca38be0f79","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"766fcf017deb4c8b0c260ac4c8d2e3489407ad89","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"35539a1ce8476e75515015a06d01ec66e4af6834","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4c6fffc6d4a3b8830931800ee7da99dccf1be36e","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":1620825203971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":1620825203971},{"_id":"source/img/notes/2020-3-27_1_34.png","hash":"78a6c7178b6c3ce1294b229f28d5d1ed03fa4695","modified":1624429431959},{"_id":"public/local-search.xml","hash":"2cb3bef8c1b47bd4b3f4b698830a498b8f08f8b2","modified":1626601095060},{"_id":"public/about/index.html","hash":"bd1bb3f9b1951cfa8ea9df612ca4ddec1fcdb791","modified":1626601095060},{"_id":"public/tags/Git/index.html","hash":"6297084ea8c89796d16ea46eebc463dcbf417ab7","modified":1626601095060},{"_id":"public/tags/RESTful-API/index.html","hash":"4f6ac5483bd400bd30f7beb0d93bf30bf446274f","modified":1626601095060},{"_id":"public/tags/计算机基础/index.html","hash":"46fb05f505e75c2f2b1558357a58f7c057565894","modified":1626601095060},{"_id":"public/archives/2018/index.html","hash":"18d9c0aa96c7e8162b3e75766a13c0b8b999bb31","modified":1626601095060},{"_id":"public/archives/index.html","hash":"2f5611ed5b30812ab61c01b8b668f420bb41913b","modified":1626601095060},{"_id":"public/archives/2018/05/index.html","hash":"18d9c0aa96c7e8162b3e75766a13c0b8b999bb31","modified":1626601095060},{"_id":"public/archives/2020/03/index.html","hash":"8d60790a567aa3165178f4351fdc8136ee55281a","modified":1626601095060},{"_id":"public/archives/2021/index.html","hash":"c19e8e5bef2bd1f6617a566fbfa15e1fb2b76d50","modified":1626601095060},{"_id":"public/archives/2020/index.html","hash":"8d60790a567aa3165178f4351fdc8136ee55281a","modified":1626601095060},{"_id":"public/archives/2021/05/index.html","hash":"c19e8e5bef2bd1f6617a566fbfa15e1fb2b76d50","modified":1626601095060},{"_id":"public/index.html","hash":"8c08192a51403931dfdc322abc4c8e1418c1e8ec","modified":1626601095060},{"_id":"public/404.html","hash":"de277818ce79617f40440e02697a007f534d96a5","modified":1626601095060},{"_id":"public/2021/05/14/RESTful-API/index.html","hash":"4614f81468ce517ffc84a48788cfaaa5675016ce","modified":1626601095060},{"_id":"public/2018/05/19/Git指南/index.html","hash":"f33998ed627d6796cb4bd9019f0a9bd4c54b840b","modified":1626601095060},{"_id":"public/2020/03/27/计算机网络/index.html","hash":"03660fdb91a17d1be7e2bfa53586ca0404109dfb","modified":1626601095060},{"_id":"public/tags/index.html","hash":"a4c951c5c0dc8aa4e85f9751b9aa30df2de54c9a","modified":1626601095060},{"_id":"public/categories/index.html","hash":"e5316c926302d914f770cc80c004ca138562f4a3","modified":1626601095060},{"_id":"public/links/index.html","hash":"9e0546f9653a5afe00bf6f6e99e342f37575b4f4","modified":1626601095060},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1626601095060},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1626601095060},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1626601095060},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1626601095060},{"_id":"public/CNAME","hash":"73518e4c29bbf9766312b8c48fdaa190b124d427","modified":1626601095060},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1626601095060},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_10.png","hash":"ffdbca5565636d3419c489c9c48b863ccb323754","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_13.png","hash":"2a0eb2c3689465e9c17d83c5b6655bcb9b35f62c","modified":1626601095060},{"_id":"public/img/bg/favicon.png","hash":"6c13328965ee7bca93c170bdfeec78d24cfa4d81","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_14.png","hash":"092ccbc5bfa90ddd9dfddc74403d8ed0423ef657","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_2.png","hash":"722e02cab418a52f32908011aa1bc3d4434f5141","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_3.png","hash":"e90fb4539564d657520a2947a2bba61233a8fda8","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_5.png","hash":"d5154aaad1f6d7a8a61910e75d0517fbac371b77","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_7.png","hash":"74368fd3eafe6fac58959b205e2251622b08b9be","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_4.png","hash":"ed7a089471712369283e68f5e1374e397796ec85","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_11.png","hash":"2bb05158e27b591984e4170c2dbe6a200597caea","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_6.png","hash":"ab103e3e61b294c46b84b17931e65f69dfb82be8","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_12.png","hash":"0308420956c1e6e8bf40e9e0e1e3eabd59b9420f","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_13.png","hash":"027b464b744f86ccee96349db51cf677b84f005a","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_15.png","hash":"47d8e335e0169add1860a2bdf0e5775b41c50211","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_10.png","hash":"7f44667c01b847654c81d7660ef789d85cba28aa","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_1.png","hash":"bc12a10b29cdbab5978e3e96aab83fba9564801e","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_14.png","hash":"fd5275b53ffe344a848f361a7d46162e502b7e61","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_17.png","hash":"4913fa075f6ead0ae854aed1aef9021c0fc1cc2f","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_18.png","hash":"976cabbb186ac7ffc73feb4202e2109fa730615d","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_16.png","hash":"e7317b8cf79ffdbf63b0f69f8705d8c7e7e174ac","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_20.png","hash":"1fc4d6daa45b04cc85814996b92993264cc47282","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_19.png","hash":"137adc794b54e3892726e5f6e2acd84db58a7bed","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_23.png","hash":"bd450151385fce6f37f53927f8e69662433695fa","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_2.png","hash":"4da26f0c4a3990d09c8285139fb2791c96edfddb","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_24.png","hash":"caff0d99f64c60da989bcc6cb1ce5a1c11551f2b","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_22.png","hash":"bbaac9f0e7d872aa3c134e154c2661596bb152c0","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_27.png","hash":"db99ebff1e1e98da4d3b3bfce6fb53b80af29bc1","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_30.png","hash":"6b70fbd50364af3b6e56e2c612ee66e286c42297","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_3.png","hash":"b3d3a8bcc85bce87ba513fcf9a84c43e28fae659","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_28.png","hash":"6508cb73ca9a25466319a3a6a243824d04a9198f","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_29.png","hash":"23b0194ad6adeb94ddebb60faabdc5c01622e548","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_32.png","hash":"94f6cdefbdbbe68b7accd8125cbd9ba02aacb57d","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_31.png","hash":"dcaf412969518914853a7d3678758e6831689466","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_33.png","hash":"a32e4390b8b77affcf59e3ec1756fd848bba4fc6","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_7.png","hash":"8a1d37fe63a19316bafb4cc60b609fd694a081bd","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_9.png","hash":"292e3427268633c898c8574f0b1b3b1732129241","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_5.png","hash":"d5c0dcd68a71b35bc7cdaf67e1bf40fff4ad879c","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_8.png","hash":"42693874d3c5f87c73742513a224542543b6e418","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_8.png","hash":"ae47c09cbc458436f312c3523d7473bb44380d93","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_9.png","hash":"4433aa83147852d8abaa5ac6183a23b39f44dce2","modified":1626601095060},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1626601095060},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1626601095060},{"_id":"public/js/local-search.js","hash":"702cd88097274924971292c042ae4955999c3a4b","modified":1626601095060},{"_id":"public/js/plugins.js","hash":"d1aef2da328e10dadcd403eaea95d6f6e4665622","modified":1626601095060},{"_id":"public/js/events.js","hash":"f7fd69496ffc156cc1c224fb8d26c46d5b437425","modified":1626601095060},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1626601095060},{"_id":"public/js/utils.js","hash":"ae5685ce20424d1c3c9b2cd983ed5f80a81b7002","modified":1626601095060},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1626601095060},{"_id":"public/js/leancloud.js","hash":"4701f49b3dc62939adff5cc11f6d21963df7f135","modified":1626601095060},{"_id":"public/js/color-schema.js","hash":"7d7444387e549e06a4a378706df92558de62e4e7","modified":1626601095060},{"_id":"public/css/main.css","hash":"85037ea97366464c417f138b216ec24c61b0f431","modified":1626601095060},{"_id":"public/img/bg/banner.jpeg","hash":"6934adcdaf0e54e7908c5452ab72a54747dc2e48","modified":1626601095060},{"_id":"public/img/bg/post_banner.jpeg","hash":"94c7e900160fd6db2fbc392cd331f19c4769836e","modified":1626601095060},{"_id":"public/img/notes/2018-5-19_1_12.png","hash":"41cc668b18654086e561eae25fd15d3bfb9768f0","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_21.png","hash":"ad89f1aca9c13955fdf168848ed42206321cf34b","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_26.png","hash":"deebf40e933f27cf702794f115f286cd6cc9a825","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_25.png","hash":"9ab6e92faff995afb7e5a4f726799ab376a111ba","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_11.png","hash":"8941af45cb26e2194d2a47ad2079207b7821c2db","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_6.png","hash":"3f03d68d1f5d1d6eb2ebe5f2dd3f1100a85a8f85","modified":1626601095060},{"_id":"public/img/notes/2020-3-27_1_34.png","hash":"78a6c7178b6c3ce1294b229f28d5d1ed03fa4695","modified":1626601095060}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2021-05-12T13:38:42.000Z","layout":"about","_content":"\n这里什么也没有（＞人＜；）...\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-05-12 21:38:42\nlayout: about\n---\n\n这里什么也没有（＞人＜；）...\n","updated":"2021-05-14T07:36:18.469Z","path":"about/index.html","comments":1,"_id":"ckr90alnw0000as7i1slfe5tn","content":"<p>这里什么也没有（＞人＜；）…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里什么也没有（＞人＜；）…</p>\n"}],"Post":[{"title":"Git指南","date":"2018-05-19T07:05:03.000Z","_content":"\n## Git 的工作流程\n\nGit 的工作流程一般如下：\n\n1. 在工作目录中添加、修改文件\n2. 将需要进行版本管理的文件放入暂存区域\n3. 将暂存区域的文件提交到 Git 仓库\n\n## 将工作目录的文件放到 Git 仓库\n\n- git init\n- git add 文件名\n- git commit -m \"提交的注释\"\n\n## 查看状态\n\nGit 管理的文件有三种状态：\n\n- 已修改（modified）\n- 已暂存（staged）\n- 已提交（committed）\n\n要随时掌握工作区的状态，使用`git status`命令。\n\n当工作目录中文件有增加修改等新状态时，`git status`有红色提示。\n\n![查看Git状态](/img/notes/2018-5-19_1_2.png)\n\n`git reset HEAD \"文件名\"` 将最近一次提交到暂存区的文件移除\n\n![移除暂存区](/img/notes/2018-5-19_1_3.png)\n\n重新提交**LICENSE**到暂存区并提交到 Git 仓库\n\n![加入暂存区并提交](/img/notes/2018-5-19_1_4.png)\n\n修改**LICENSE**文件中的内容后，用`git status`查看状态\n\n![修改文件后的状态](/img/notes/2018-5-19_1_5.png)\n此时的状态为上述提到的*modified*状态\n\n该状态下有两种选项\n撤销修改：\n`git checkout -- <filename>`该选项有两种情况：\n\n1、LICENSE 自修改后还没有被放到暂存区，现在，撤销修改就是将上次存到 Git 仓库的文件*还原*到当前工作目录文件；\n\n2、LICENSE 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。\n\n保存修改：\n`git add <filename>`该选项将本次修改后的文件*更新*到暂存区，覆盖上次提交的内容\n\n用撤销修改命令还原上次储存到仓库中的内容（此时没有放入暂存区）后，并重新修改 LICENSE 文件，并用第二条命令添加到暂存区，并提交到仓库\n\n![修改文件后的选项](/img/notes/2018-5-19_1_6.png)\n\n## 查看历史提交\n\n`git log`可以加上`--pretty=oneline`参数`git log --pretty=oneline`\n\n![提交记录](/img/notes/2018-5-19_1_7.png)\n\n通过上述操作，一共对 Git 仓库进行了三次提交。\n\n## 版本回退\n\n版本回退分三种情况：\n1、当你修改了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- <file>`，上述所讲的撤销修改。\n\n2、当你修改工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD <file>`，就回到了情况 1，第二步按情况 1 操作。\n\n3、已经提交了不合适的修改到 Git 仓库时，想要撤销本次提交，前提是没有推送到远程库时，用`git reset --hard HEAD^`命令。Git 必须知道当前版本是哪个版本，在 Git 中，用 HEAD 表示当前版本，也就是最新的提交提交 ID，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 HEAD~100。\n\n当前工作目录、暂存区、Git 仓库状态如下：\n\n![三个区域状态](/img/notes/2018-5-19_1_8.png)\n\n当使用命令`git reset HEAD~`后：\n\n![三个区域回退版本后状态](/img/notes/2018-5-19_1_9.png)\n\n此时使用`git status`命令查看：\n\n![三个区域回退版本后状态](/img/notes/2018-5-19_1_10.png)\n\n### reset命令的选项\n\n`git reset --mixed HEAD~`（默认）\n1、移动HEAD的指向，将其指向上一个版本\n2、将HEAD移动后指向的版本回滚到暂存区域\n\n`git reset --soft HEAD~`\n1、移动HEAD的指向，将其指向上一个版本\n  \n`git reset --hard HEAD~`\n1、移动HEAD的指向，将其指向上一个版本\n2、将HEAD移动后指向的版本回滚到暂存区域\n3、将暂存区域的文件还原到工作目录\n\n## 版本前滚\n\n`git reset --<> 版本ID号` 版本号没必要写全，前几位就可以了。\n\n### 版本号获取\n\n1. 命令行窗口还没有被关掉，可以顺着往上找，就可以指定回到未来的某个版本。\n2. Git提供了一个命令`git reflog`用来记录你的每一次命令：\n  ![命令记录](/img/notes/2018-5-19_1_11.png)\n\n## 版本对比\n\n### 比较暂存区与工作区\n\n`git diff`\n\n### 比较两个历史快照\n\n`git diff 版本ID1 版本ID2`\n\n### 比较当前工作区和仓库版本\n\n`git diff 版本ID`\n\n### 比较暂存区和仓库版本\n\n`git diff --cached 版本ID`\n\n![版本对比总结](/img/notes/2018-5-19_1_12.png)\n  \n## 修改最后一次提交\n\n实际开发过程中，可能遇到两种情况：\n1、版本刚提交（commit）到仓库，突然想起漏掉两个文件没有添加（add）\n2、版本提交（commit）到仓库后，发现版本说明写的不全面。\n  \n解决方法：`git commit --amend` Git会更正”最近“一次的提交。\n第一种情况先将漏掉的文件添加到暂存区，然后再执行命令：\n![修改最后提交](/img/notes/2018-5-19_1_13.png)\n\n进入后按i进入INSERT，按ESC退出INSERT。`SHIFT+ZZ`保存退出，`:q!`不保存退出\n\n## 删除文件和文件误删\n\n### 文件误删\n\n![恢复误删文件](/img/notes/2018-5-19_1_14.png)\n\n### 删除文件\n\n`git rm 文件名`\n该命令删除的只是工作目录和暂存区域的文件，也就是取消跟踪，在下次提交时不纳入版本管理。\n若此时工作目录与暂存区域文件不同，工作区文件还未重新添加（add）：`git rm -f <filename>`可以同时删除两个文件。\n如果只删除暂存区域的文件（保留工作目录）：`git rm --cached <filename>`可以删除暂存区文件\n\n## 重命名文件\n\n`git mv 旧文件名 新文件名`\n\n## 创建和切换分支\n\n### 创建分支\n\n`git branch 分支名`\n\n### 切换分支\n\n`git checkout 分支名`\n\n> 创建并切换到分支：`git checkout -b 分支名`\n\n### 分支操作\n\n然后，用`git branch`命令查看当前分支：\n`git branch`命令会列出所有分支，当前分支前面会标一个\\*号。\n\n#### 合并分支\n\n1、“Fast-forward”快进模式\n新分支提交后主分支无新提交。\n合并某分支到当前分支：`git merge 分支名`\n2、冲突合并\nmaster 主分支和新分支各自都分别有新的提交，这种情况下，`git merge 分支名`无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，必须手动在冲突文件中解决冲突后再提交。\n`git log --graph`命令可以看到分支合并图。\n合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。\n\n#### 删除分支\n\n`git branch -d 分支名`\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <分支名`强行删除。\n\n#### Bug 分支\n\n修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复 bug，修复后，再`git stash pop`，回到工作现场。\n\n#### 多人合作\n\n`git push origin 分支名`推送分支到远程仓库\n\n## 远程仓库\n\n### 添加远程库\n\n登陆 GitHub，然后，在右上角找到“Create a new repo”按钮创建一个新的仓库，在 Repository name 填入仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库。\n要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`；\n关联后，使用命令`git push -u origin master`第一次推送 master 分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改。如果推送失败,先用`git pull`抓取远程的新提交。\n\n### 从远程库克隆\n\n假设从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆 GitHub，创建一个新的仓库\n`git clone git@github.com:WangCheng96/webStudy.git`\n\n### 小结\n\n1、查看远程库信息，使用`git remote -v`。\n2、在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致。\n3、建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`。\n4、从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n## 标签管理\n\n### 创建标签\n\n`git tag <tagname>`用于新建一个标签，默认为 HEAD，也可以指定一个 commit id；\n`git tag -a <tagname> -m \"blablabla...\"`可以指定标签信息；\n`git tag`可以查看所有标签。\n\n### 操作标签\n\n`git push origin <tagname>`可以推送一个本地标签；\n`git push origin --tags`可以推送全部未推送过的本地标签；\n`git tag -d <tagname>`可以删除一个本地标签；\n`git push origin :refs/tags/<tagname>`可以删除一个远程标签。\n\n## 用 Git Subtree 在多个 Git 项目间双向同步子项目\n\n### 什么时候需要 Subtree\n\n- 当多个项目共用同一坨代码，而这坨代码跟着项目在快速更新的时候\n- 把一部分代码迁移出去独立为一个新的 git 仓库，但又希望能够保留这部分代码的历史提交记录。\n","source":"_posts/Git指南.md","raw":"---\ntitle: Git指南\ndate: 2018-05-19 15:05:03\ntags: ['Git']\n---\n\n## Git 的工作流程\n\nGit 的工作流程一般如下：\n\n1. 在工作目录中添加、修改文件\n2. 将需要进行版本管理的文件放入暂存区域\n3. 将暂存区域的文件提交到 Git 仓库\n\n## 将工作目录的文件放到 Git 仓库\n\n- git init\n- git add 文件名\n- git commit -m \"提交的注释\"\n\n## 查看状态\n\nGit 管理的文件有三种状态：\n\n- 已修改（modified）\n- 已暂存（staged）\n- 已提交（committed）\n\n要随时掌握工作区的状态，使用`git status`命令。\n\n当工作目录中文件有增加修改等新状态时，`git status`有红色提示。\n\n![查看Git状态](/img/notes/2018-5-19_1_2.png)\n\n`git reset HEAD \"文件名\"` 将最近一次提交到暂存区的文件移除\n\n![移除暂存区](/img/notes/2018-5-19_1_3.png)\n\n重新提交**LICENSE**到暂存区并提交到 Git 仓库\n\n![加入暂存区并提交](/img/notes/2018-5-19_1_4.png)\n\n修改**LICENSE**文件中的内容后，用`git status`查看状态\n\n![修改文件后的状态](/img/notes/2018-5-19_1_5.png)\n此时的状态为上述提到的*modified*状态\n\n该状态下有两种选项\n撤销修改：\n`git checkout -- <filename>`该选项有两种情况：\n\n1、LICENSE 自修改后还没有被放到暂存区，现在，撤销修改就是将上次存到 Git 仓库的文件*还原*到当前工作目录文件；\n\n2、LICENSE 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。\n\n保存修改：\n`git add <filename>`该选项将本次修改后的文件*更新*到暂存区，覆盖上次提交的内容\n\n用撤销修改命令还原上次储存到仓库中的内容（此时没有放入暂存区）后，并重新修改 LICENSE 文件，并用第二条命令添加到暂存区，并提交到仓库\n\n![修改文件后的选项](/img/notes/2018-5-19_1_6.png)\n\n## 查看历史提交\n\n`git log`可以加上`--pretty=oneline`参数`git log --pretty=oneline`\n\n![提交记录](/img/notes/2018-5-19_1_7.png)\n\n通过上述操作，一共对 Git 仓库进行了三次提交。\n\n## 版本回退\n\n版本回退分三种情况：\n1、当你修改了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- <file>`，上述所讲的撤销修改。\n\n2、当你修改工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD <file>`，就回到了情况 1，第二步按情况 1 操作。\n\n3、已经提交了不合适的修改到 Git 仓库时，想要撤销本次提交，前提是没有推送到远程库时，用`git reset --hard HEAD^`命令。Git 必须知道当前版本是哪个版本，在 Git 中，用 HEAD 表示当前版本，也就是最新的提交提交 ID，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 HEAD~100。\n\n当前工作目录、暂存区、Git 仓库状态如下：\n\n![三个区域状态](/img/notes/2018-5-19_1_8.png)\n\n当使用命令`git reset HEAD~`后：\n\n![三个区域回退版本后状态](/img/notes/2018-5-19_1_9.png)\n\n此时使用`git status`命令查看：\n\n![三个区域回退版本后状态](/img/notes/2018-5-19_1_10.png)\n\n### reset命令的选项\n\n`git reset --mixed HEAD~`（默认）\n1、移动HEAD的指向，将其指向上一个版本\n2、将HEAD移动后指向的版本回滚到暂存区域\n\n`git reset --soft HEAD~`\n1、移动HEAD的指向，将其指向上一个版本\n  \n`git reset --hard HEAD~`\n1、移动HEAD的指向，将其指向上一个版本\n2、将HEAD移动后指向的版本回滚到暂存区域\n3、将暂存区域的文件还原到工作目录\n\n## 版本前滚\n\n`git reset --<> 版本ID号` 版本号没必要写全，前几位就可以了。\n\n### 版本号获取\n\n1. 命令行窗口还没有被关掉，可以顺着往上找，就可以指定回到未来的某个版本。\n2. Git提供了一个命令`git reflog`用来记录你的每一次命令：\n  ![命令记录](/img/notes/2018-5-19_1_11.png)\n\n## 版本对比\n\n### 比较暂存区与工作区\n\n`git diff`\n\n### 比较两个历史快照\n\n`git diff 版本ID1 版本ID2`\n\n### 比较当前工作区和仓库版本\n\n`git diff 版本ID`\n\n### 比较暂存区和仓库版本\n\n`git diff --cached 版本ID`\n\n![版本对比总结](/img/notes/2018-5-19_1_12.png)\n  \n## 修改最后一次提交\n\n实际开发过程中，可能遇到两种情况：\n1、版本刚提交（commit）到仓库，突然想起漏掉两个文件没有添加（add）\n2、版本提交（commit）到仓库后，发现版本说明写的不全面。\n  \n解决方法：`git commit --amend` Git会更正”最近“一次的提交。\n第一种情况先将漏掉的文件添加到暂存区，然后再执行命令：\n![修改最后提交](/img/notes/2018-5-19_1_13.png)\n\n进入后按i进入INSERT，按ESC退出INSERT。`SHIFT+ZZ`保存退出，`:q!`不保存退出\n\n## 删除文件和文件误删\n\n### 文件误删\n\n![恢复误删文件](/img/notes/2018-5-19_1_14.png)\n\n### 删除文件\n\n`git rm 文件名`\n该命令删除的只是工作目录和暂存区域的文件，也就是取消跟踪，在下次提交时不纳入版本管理。\n若此时工作目录与暂存区域文件不同，工作区文件还未重新添加（add）：`git rm -f <filename>`可以同时删除两个文件。\n如果只删除暂存区域的文件（保留工作目录）：`git rm --cached <filename>`可以删除暂存区文件\n\n## 重命名文件\n\n`git mv 旧文件名 新文件名`\n\n## 创建和切换分支\n\n### 创建分支\n\n`git branch 分支名`\n\n### 切换分支\n\n`git checkout 分支名`\n\n> 创建并切换到分支：`git checkout -b 分支名`\n\n### 分支操作\n\n然后，用`git branch`命令查看当前分支：\n`git branch`命令会列出所有分支，当前分支前面会标一个\\*号。\n\n#### 合并分支\n\n1、“Fast-forward”快进模式\n新分支提交后主分支无新提交。\n合并某分支到当前分支：`git merge 分支名`\n2、冲突合并\nmaster 主分支和新分支各自都分别有新的提交，这种情况下，`git merge 分支名`无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，必须手动在冲突文件中解决冲突后再提交。\n`git log --graph`命令可以看到分支合并图。\n合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。\n\n#### 删除分支\n\n`git branch -d 分支名`\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <分支名`强行删除。\n\n#### Bug 分支\n\n修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复 bug，修复后，再`git stash pop`，回到工作现场。\n\n#### 多人合作\n\n`git push origin 分支名`推送分支到远程仓库\n\n## 远程仓库\n\n### 添加远程库\n\n登陆 GitHub，然后，在右上角找到“Create a new repo”按钮创建一个新的仓库，在 Repository name 填入仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库。\n要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`；\n关联后，使用命令`git push -u origin master`第一次推送 master 分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改。如果推送失败,先用`git pull`抓取远程的新提交。\n\n### 从远程库克隆\n\n假设从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆 GitHub，创建一个新的仓库\n`git clone git@github.com:WangCheng96/webStudy.git`\n\n### 小结\n\n1、查看远程库信息，使用`git remote -v`。\n2、在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致。\n3、建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`。\n4、从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n## 标签管理\n\n### 创建标签\n\n`git tag <tagname>`用于新建一个标签，默认为 HEAD，也可以指定一个 commit id；\n`git tag -a <tagname> -m \"blablabla...\"`可以指定标签信息；\n`git tag`可以查看所有标签。\n\n### 操作标签\n\n`git push origin <tagname>`可以推送一个本地标签；\n`git push origin --tags`可以推送全部未推送过的本地标签；\n`git tag -d <tagname>`可以删除一个本地标签；\n`git push origin :refs/tags/<tagname>`可以删除一个远程标签。\n\n## 用 Git Subtree 在多个 Git 项目间双向同步子项目\n\n### 什么时候需要 Subtree\n\n- 当多个项目共用同一坨代码，而这坨代码跟着项目在快速更新的时候\n- 把一部分代码迁移出去独立为一个新的 git 仓库，但又希望能够保留这部分代码的历史提交记录。\n","slug":"Git指南","published":1,"updated":"2021-07-18T09:36:15.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr90alny0001as7ih13yar63","content":"<h2 id=\"Git-的工作流程\"><a href=\"#Git-的工作流程\" class=\"headerlink\" title=\"Git 的工作流程\"></a>Git 的工作流程</h2><p>Git 的工作流程一般如下：</p>\n<ol>\n<li>在工作目录中添加、修改文件</li>\n<li>将需要进行版本管理的文件放入暂存区域</li>\n<li>将暂存区域的文件提交到 Git 仓库</li>\n</ol>\n<h2 id=\"将工作目录的文件放到-Git-仓库\"><a href=\"#将工作目录的文件放到-Git-仓库\" class=\"headerlink\" title=\"将工作目录的文件放到 Git 仓库\"></a>将工作目录的文件放到 Git 仓库</h2><ul>\n<li>git init</li>\n<li>git add 文件名</li>\n<li>git commit -m “提交的注释”</li>\n</ul>\n<h2 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h2><p>Git 管理的文件有三种状态：</p>\n<ul>\n<li>已修改（modified）</li>\n<li>已暂存（staged）</li>\n<li>已提交（committed）</li>\n</ul>\n<p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p>\n<p>当工作目录中文件有增加修改等新状态时，<code>git status</code>有红色提示。</p>\n<p><img src=\"/img/notes/2018-5-19_1_2.png\" alt=\"查看Git状态\"></p>\n<p><code>git reset HEAD &quot;文件名&quot;</code> 将最近一次提交到暂存区的文件移除</p>\n<p><img src=\"/img/notes/2018-5-19_1_3.png\" alt=\"移除暂存区\"></p>\n<p>重新提交<strong>LICENSE</strong>到暂存区并提交到 Git 仓库</p>\n<p><img src=\"/img/notes/2018-5-19_1_4.png\" alt=\"加入暂存区并提交\"></p>\n<p>修改<strong>LICENSE</strong>文件中的内容后，用<code>git status</code>查看状态</p>\n<p><img src=\"/img/notes/2018-5-19_1_5.png\" alt=\"修改文件后的状态\"><br>此时的状态为上述提到的<em>modified</em>状态</p>\n<p>该状态下有两种选项<br>撤销修改：<br><code>git checkout -- &lt;filename&gt;</code>该选项有两种情况：</p>\n<p>1、LICENSE 自修改后还没有被放到暂存区，现在，撤销修改就是将上次存到 Git 仓库的文件<em>还原</em>到当前工作目录文件；</p>\n<p>2、LICENSE 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>\n<p>保存修改：<br><code>git add &lt;filename&gt;</code>该选项将本次修改后的文件<em>更新</em>到暂存区，覆盖上次提交的内容</p>\n<p>用撤销修改命令还原上次储存到仓库中的内容（此时没有放入暂存区）后，并重新修改 LICENSE 文件，并用第二条命令添加到暂存区，并提交到仓库</p>\n<p><img src=\"/img/notes/2018-5-19_1_6.png\" alt=\"修改文件后的选项\"></p>\n<h2 id=\"查看历史提交\"><a href=\"#查看历史提交\" class=\"headerlink\" title=\"查看历史提交\"></a>查看历史提交</h2><p><code>git log</code>可以加上<code>--pretty=oneline</code>参数<code>git log --pretty=oneline</code></p>\n<p><img src=\"/img/notes/2018-5-19_1_7.png\" alt=\"提交记录\"></p>\n<p>通过上述操作，一共对 Git 仓库进行了三次提交。</p>\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><p>版本回退分三种情况：<br>1、当你修改了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>，上述所讲的撤销修改。</p>\n<p>2、当你修改工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了情况 1，第二步按情况 1 操作。</p>\n<p>3、已经提交了不合适的修改到 Git 仓库时，想要撤销本次提交，前提是没有推送到远程库时，用<code>git reset --hard HEAD^</code>命令。Git 必须知道当前版本是哪个版本，在 Git 中，用 HEAD 表示当前版本，也就是最新的提交提交 ID，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 HEAD~100。</p>\n<p>当前工作目录、暂存区、Git 仓库状态如下：</p>\n<p><img src=\"/img/notes/2018-5-19_1_8.png\" alt=\"三个区域状态\"></p>\n<p>当使用命令<code>git reset HEAD~</code>后：</p>\n<p><img src=\"/img/notes/2018-5-19_1_9.png\" alt=\"三个区域回退版本后状态\"></p>\n<p>此时使用<code>git status</code>命令查看：</p>\n<p><img src=\"/img/notes/2018-5-19_1_10.png\" alt=\"三个区域回退版本后状态\"></p>\n<h3 id=\"reset命令的选项\"><a href=\"#reset命令的选项\" class=\"headerlink\" title=\"reset命令的选项\"></a>reset命令的选项</h3><p><code>git reset --mixed HEAD~</code>（默认）<br>1、移动HEAD的指向，将其指向上一个版本<br>2、将HEAD移动后指向的版本回滚到暂存区域</p>\n<p><code>git reset --soft HEAD~</code><br>1、移动HEAD的指向，将其指向上一个版本</p>\n<p><code>git reset --hard HEAD~</code><br>1、移动HEAD的指向，将其指向上一个版本<br>2、将HEAD移动后指向的版本回滚到暂存区域<br>3、将暂存区域的文件还原到工作目录</p>\n<h2 id=\"版本前滚\"><a href=\"#版本前滚\" class=\"headerlink\" title=\"版本前滚\"></a>版本前滚</h2><p><code>git reset --&lt;&gt; 版本ID号</code> 版本号没必要写全，前几位就可以了。</p>\n<h3 id=\"版本号获取\"><a href=\"#版本号获取\" class=\"headerlink\" title=\"版本号获取\"></a>版本号获取</h3><ol>\n<li>命令行窗口还没有被关掉，可以顺着往上找，就可以指定回到未来的某个版本。</li>\n<li>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：<br><img src=\"/img/notes/2018-5-19_1_11.png\" alt=\"命令记录\"></li>\n</ol>\n<h2 id=\"版本对比\"><a href=\"#版本对比\" class=\"headerlink\" title=\"版本对比\"></a>版本对比</h2><h3 id=\"比较暂存区与工作区\"><a href=\"#比较暂存区与工作区\" class=\"headerlink\" title=\"比较暂存区与工作区\"></a>比较暂存区与工作区</h3><p><code>git diff</code></p>\n<h3 id=\"比较两个历史快照\"><a href=\"#比较两个历史快照\" class=\"headerlink\" title=\"比较两个历史快照\"></a>比较两个历史快照</h3><p><code>git diff 版本ID1 版本ID2</code></p>\n<h3 id=\"比较当前工作区和仓库版本\"><a href=\"#比较当前工作区和仓库版本\" class=\"headerlink\" title=\"比较当前工作区和仓库版本\"></a>比较当前工作区和仓库版本</h3><p><code>git diff 版本ID</code></p>\n<h3 id=\"比较暂存区和仓库版本\"><a href=\"#比较暂存区和仓库版本\" class=\"headerlink\" title=\"比较暂存区和仓库版本\"></a>比较暂存区和仓库版本</h3><p><code>git diff --cached 版本ID</code></p>\n<p><img src=\"/img/notes/2018-5-19_1_12.png\" alt=\"版本对比总结\"></p>\n<h2 id=\"修改最后一次提交\"><a href=\"#修改最后一次提交\" class=\"headerlink\" title=\"修改最后一次提交\"></a>修改最后一次提交</h2><p>实际开发过程中，可能遇到两种情况：<br>1、版本刚提交（commit）到仓库，突然想起漏掉两个文件没有添加（add）<br>2、版本提交（commit）到仓库后，发现版本说明写的不全面。</p>\n<p>解决方法：<code>git commit --amend</code> Git会更正”最近“一次的提交。<br>第一种情况先将漏掉的文件添加到暂存区，然后再执行命令：<br><img src=\"/img/notes/2018-5-19_1_13.png\" alt=\"修改最后提交\"></p>\n<p>进入后按i进入INSERT，按ESC退出INSERT。<code>SHIFT+ZZ</code>保存退出，<code>:q!</code>不保存退出</p>\n<h2 id=\"删除文件和文件误删\"><a href=\"#删除文件和文件误删\" class=\"headerlink\" title=\"删除文件和文件误删\"></a>删除文件和文件误删</h2><h3 id=\"文件误删\"><a href=\"#文件误删\" class=\"headerlink\" title=\"文件误删\"></a>文件误删</h3><p><img src=\"/img/notes/2018-5-19_1_14.png\" alt=\"恢复误删文件\"></p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p><code>git rm 文件名</code><br>该命令删除的只是工作目录和暂存区域的文件，也就是取消跟踪，在下次提交时不纳入版本管理。<br>若此时工作目录与暂存区域文件不同，工作区文件还未重新添加（add）：<code>git rm -f &lt;filename&gt;</code>可以同时删除两个文件。<br>如果只删除暂存区域的文件（保留工作目录）：<code>git rm --cached &lt;filename&gt;</code>可以删除暂存区文件</p>\n<h2 id=\"重命名文件\"><a href=\"#重命名文件\" class=\"headerlink\" title=\"重命名文件\"></a>重命名文件</h2><p><code>git mv 旧文件名 新文件名</code></p>\n<h2 id=\"创建和切换分支\"><a href=\"#创建和切换分支\" class=\"headerlink\" title=\"创建和切换分支\"></a>创建和切换分支</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><p><code>git branch 分支名</code></p>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><p><code>git checkout 分支名</code></p>\n<blockquote>\n<p>创建并切换到分支：<code>git checkout -b 分支名</code></p>\n</blockquote>\n<h3 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h3><p>然后，用<code>git branch</code>命令查看当前分支：<br><code>git branch</code>命令会列出所有分支，当前分支前面会标一个*号。</p>\n<h4 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h4><p>1、“Fast-forward”快进模式<br>新分支提交后主分支无新提交。<br>合并某分支到当前分支：<code>git merge 分支名</code><br>2、冲突合并<br>master 主分支和新分支各自都分别有新的提交，这种情况下，<code>git merge 分支名</code>无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，必须手动在冲突文件中解决冲突后再提交。<br><code>git log --graph</code>命令可以看到分支合并图。<br>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。</p>\n<h4 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h4><p><code>git branch -d 分支名</code><br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;分支名</code>强行删除。</p>\n<h4 id=\"Bug-分支\"><a href=\"#Bug-分支\" class=\"headerlink\" title=\"Bug 分支\"></a>Bug 分支</h4><p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复 bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>\n<h4 id=\"多人合作\"><a href=\"#多人合作\" class=\"headerlink\" title=\"多人合作\"></a>多人合作</h4><p><code>git push origin 分支名</code>推送分支到远程仓库</p>\n<h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><h3 id=\"添加远程库\"><a href=\"#添加远程库\" class=\"headerlink\" title=\"添加远程库\"></a>添加远程库</h3><p>登陆 GitHub，然后，在右上角找到“Create a new repo”按钮创建一个新的仓库，在 Repository name 填入仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库。<br>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；<br>关联后，使用命令<code>git push -u origin master</code>第一次推送 master 分支的所有内容；<br>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。如果推送失败,先用<code>git pull</code>抓取远程的新提交。</p>\n<h3 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆\"></a>从远程库克隆</h3><p>假设从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆 GitHub，创建一个新的仓库<br><code>git clone git@github.com:WangCheng96/webStudy.git</code></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>1、查看远程库信息，使用<code>git remote -v</code>。<br>2、在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致。<br>3、建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>。<br>4、从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>\n<h2 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h2><h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><p><code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为 HEAD，也可以指定一个 commit id；<br><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；<br><code>git tag</code>可以查看所有标签。</p>\n<h3 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h3><p><code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；<br><code>git push origin --tags</code>可以推送全部未推送过的本地标签；<br><code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；<br><code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>\n<h2 id=\"用-Git-Subtree-在多个-Git-项目间双向同步子项目\"><a href=\"#用-Git-Subtree-在多个-Git-项目间双向同步子项目\" class=\"headerlink\" title=\"用 Git Subtree 在多个 Git 项目间双向同步子项目\"></a>用 Git Subtree 在多个 Git 项目间双向同步子项目</h2><h3 id=\"什么时候需要-Subtree\"><a href=\"#什么时候需要-Subtree\" class=\"headerlink\" title=\"什么时候需要 Subtree\"></a>什么时候需要 Subtree</h3><ul>\n<li>当多个项目共用同一坨代码，而这坨代码跟着项目在快速更新的时候</li>\n<li>把一部分代码迁移出去独立为一个新的 git 仓库，但又希望能够保留这部分代码的历史提交记录。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Git-的工作流程\"><a href=\"#Git-的工作流程\" class=\"headerlink\" title=\"Git 的工作流程\"></a>Git 的工作流程</h2><p>Git 的工作流程一般如下：</p>\n<ol>\n<li>在工作目录中添加、修改文件</li>\n<li>将需要进行版本管理的文件放入暂存区域</li>\n<li>将暂存区域的文件提交到 Git 仓库</li>\n</ol>\n<h2 id=\"将工作目录的文件放到-Git-仓库\"><a href=\"#将工作目录的文件放到-Git-仓库\" class=\"headerlink\" title=\"将工作目录的文件放到 Git 仓库\"></a>将工作目录的文件放到 Git 仓库</h2><ul>\n<li>git init</li>\n<li>git add 文件名</li>\n<li>git commit -m “提交的注释”</li>\n</ul>\n<h2 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h2><p>Git 管理的文件有三种状态：</p>\n<ul>\n<li>已修改（modified）</li>\n<li>已暂存（staged）</li>\n<li>已提交（committed）</li>\n</ul>\n<p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p>\n<p>当工作目录中文件有增加修改等新状态时，<code>git status</code>有红色提示。</p>\n<p><img src=\"/img/notes/2018-5-19_1_2.png\" alt=\"查看Git状态\"></p>\n<p><code>git reset HEAD &quot;文件名&quot;</code> 将最近一次提交到暂存区的文件移除</p>\n<p><img src=\"/img/notes/2018-5-19_1_3.png\" alt=\"移除暂存区\"></p>\n<p>重新提交<strong>LICENSE</strong>到暂存区并提交到 Git 仓库</p>\n<p><img src=\"/img/notes/2018-5-19_1_4.png\" alt=\"加入暂存区并提交\"></p>\n<p>修改<strong>LICENSE</strong>文件中的内容后，用<code>git status</code>查看状态</p>\n<p><img src=\"/img/notes/2018-5-19_1_5.png\" alt=\"修改文件后的状态\"><br>此时的状态为上述提到的<em>modified</em>状态</p>\n<p>该状态下有两种选项<br>撤销修改：<br><code>git checkout -- &lt;filename&gt;</code>该选项有两种情况：</p>\n<p>1、LICENSE 自修改后还没有被放到暂存区，现在，撤销修改就是将上次存到 Git 仓库的文件<em>还原</em>到当前工作目录文件；</p>\n<p>2、LICENSE 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>\n<p>保存修改：<br><code>git add &lt;filename&gt;</code>该选项将本次修改后的文件<em>更新</em>到暂存区，覆盖上次提交的内容</p>\n<p>用撤销修改命令还原上次储存到仓库中的内容（此时没有放入暂存区）后，并重新修改 LICENSE 文件，并用第二条命令添加到暂存区，并提交到仓库</p>\n<p><img src=\"/img/notes/2018-5-19_1_6.png\" alt=\"修改文件后的选项\"></p>\n<h2 id=\"查看历史提交\"><a href=\"#查看历史提交\" class=\"headerlink\" title=\"查看历史提交\"></a>查看历史提交</h2><p><code>git log</code>可以加上<code>--pretty=oneline</code>参数<code>git log --pretty=oneline</code></p>\n<p><img src=\"/img/notes/2018-5-19_1_7.png\" alt=\"提交记录\"></p>\n<p>通过上述操作，一共对 Git 仓库进行了三次提交。</p>\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><p>版本回退分三种情况：<br>1、当你修改了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>，上述所讲的撤销修改。</p>\n<p>2、当你修改工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了情况 1，第二步按情况 1 操作。</p>\n<p>3、已经提交了不合适的修改到 Git 仓库时，想要撤销本次提交，前提是没有推送到远程库时，用<code>git reset --hard HEAD^</code>命令。Git 必须知道当前版本是哪个版本，在 Git 中，用 HEAD 表示当前版本，也就是最新的提交提交 ID，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 HEAD~100。</p>\n<p>当前工作目录、暂存区、Git 仓库状态如下：</p>\n<p><img src=\"/img/notes/2018-5-19_1_8.png\" alt=\"三个区域状态\"></p>\n<p>当使用命令<code>git reset HEAD~</code>后：</p>\n<p><img src=\"/img/notes/2018-5-19_1_9.png\" alt=\"三个区域回退版本后状态\"></p>\n<p>此时使用<code>git status</code>命令查看：</p>\n<p><img src=\"/img/notes/2018-5-19_1_10.png\" alt=\"三个区域回退版本后状态\"></p>\n<h3 id=\"reset命令的选项\"><a href=\"#reset命令的选项\" class=\"headerlink\" title=\"reset命令的选项\"></a>reset命令的选项</h3><p><code>git reset --mixed HEAD~</code>（默认）<br>1、移动HEAD的指向，将其指向上一个版本<br>2、将HEAD移动后指向的版本回滚到暂存区域</p>\n<p><code>git reset --soft HEAD~</code><br>1、移动HEAD的指向，将其指向上一个版本</p>\n<p><code>git reset --hard HEAD~</code><br>1、移动HEAD的指向，将其指向上一个版本<br>2、将HEAD移动后指向的版本回滚到暂存区域<br>3、将暂存区域的文件还原到工作目录</p>\n<h2 id=\"版本前滚\"><a href=\"#版本前滚\" class=\"headerlink\" title=\"版本前滚\"></a>版本前滚</h2><p><code>git reset --&lt;&gt; 版本ID号</code> 版本号没必要写全，前几位就可以了。</p>\n<h3 id=\"版本号获取\"><a href=\"#版本号获取\" class=\"headerlink\" title=\"版本号获取\"></a>版本号获取</h3><ol>\n<li>命令行窗口还没有被关掉，可以顺着往上找，就可以指定回到未来的某个版本。</li>\n<li>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：<br><img src=\"/img/notes/2018-5-19_1_11.png\" alt=\"命令记录\"></li>\n</ol>\n<h2 id=\"版本对比\"><a href=\"#版本对比\" class=\"headerlink\" title=\"版本对比\"></a>版本对比</h2><h3 id=\"比较暂存区与工作区\"><a href=\"#比较暂存区与工作区\" class=\"headerlink\" title=\"比较暂存区与工作区\"></a>比较暂存区与工作区</h3><p><code>git diff</code></p>\n<h3 id=\"比较两个历史快照\"><a href=\"#比较两个历史快照\" class=\"headerlink\" title=\"比较两个历史快照\"></a>比较两个历史快照</h3><p><code>git diff 版本ID1 版本ID2</code></p>\n<h3 id=\"比较当前工作区和仓库版本\"><a href=\"#比较当前工作区和仓库版本\" class=\"headerlink\" title=\"比较当前工作区和仓库版本\"></a>比较当前工作区和仓库版本</h3><p><code>git diff 版本ID</code></p>\n<h3 id=\"比较暂存区和仓库版本\"><a href=\"#比较暂存区和仓库版本\" class=\"headerlink\" title=\"比较暂存区和仓库版本\"></a>比较暂存区和仓库版本</h3><p><code>git diff --cached 版本ID</code></p>\n<p><img src=\"/img/notes/2018-5-19_1_12.png\" alt=\"版本对比总结\"></p>\n<h2 id=\"修改最后一次提交\"><a href=\"#修改最后一次提交\" class=\"headerlink\" title=\"修改最后一次提交\"></a>修改最后一次提交</h2><p>实际开发过程中，可能遇到两种情况：<br>1、版本刚提交（commit）到仓库，突然想起漏掉两个文件没有添加（add）<br>2、版本提交（commit）到仓库后，发现版本说明写的不全面。</p>\n<p>解决方法：<code>git commit --amend</code> Git会更正”最近“一次的提交。<br>第一种情况先将漏掉的文件添加到暂存区，然后再执行命令：<br><img src=\"/img/notes/2018-5-19_1_13.png\" alt=\"修改最后提交\"></p>\n<p>进入后按i进入INSERT，按ESC退出INSERT。<code>SHIFT+ZZ</code>保存退出，<code>:q!</code>不保存退出</p>\n<h2 id=\"删除文件和文件误删\"><a href=\"#删除文件和文件误删\" class=\"headerlink\" title=\"删除文件和文件误删\"></a>删除文件和文件误删</h2><h3 id=\"文件误删\"><a href=\"#文件误删\" class=\"headerlink\" title=\"文件误删\"></a>文件误删</h3><p><img src=\"/img/notes/2018-5-19_1_14.png\" alt=\"恢复误删文件\"></p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p><code>git rm 文件名</code><br>该命令删除的只是工作目录和暂存区域的文件，也就是取消跟踪，在下次提交时不纳入版本管理。<br>若此时工作目录与暂存区域文件不同，工作区文件还未重新添加（add）：<code>git rm -f &lt;filename&gt;</code>可以同时删除两个文件。<br>如果只删除暂存区域的文件（保留工作目录）：<code>git rm --cached &lt;filename&gt;</code>可以删除暂存区文件</p>\n<h2 id=\"重命名文件\"><a href=\"#重命名文件\" class=\"headerlink\" title=\"重命名文件\"></a>重命名文件</h2><p><code>git mv 旧文件名 新文件名</code></p>\n<h2 id=\"创建和切换分支\"><a href=\"#创建和切换分支\" class=\"headerlink\" title=\"创建和切换分支\"></a>创建和切换分支</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><p><code>git branch 分支名</code></p>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><p><code>git checkout 分支名</code></p>\n<blockquote>\n<p>创建并切换到分支：<code>git checkout -b 分支名</code></p>\n</blockquote>\n<h3 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h3><p>然后，用<code>git branch</code>命令查看当前分支：<br><code>git branch</code>命令会列出所有分支，当前分支前面会标一个*号。</p>\n<h4 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h4><p>1、“Fast-forward”快进模式<br>新分支提交后主分支无新提交。<br>合并某分支到当前分支：<code>git merge 分支名</code><br>2、冲突合并<br>master 主分支和新分支各自都分别有新的提交，这种情况下，<code>git merge 分支名</code>无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，必须手动在冲突文件中解决冲突后再提交。<br><code>git log --graph</code>命令可以看到分支合并图。<br>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。</p>\n<h4 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h4><p><code>git branch -d 分支名</code><br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;分支名</code>强行删除。</p>\n<h4 id=\"Bug-分支\"><a href=\"#Bug-分支\" class=\"headerlink\" title=\"Bug 分支\"></a>Bug 分支</h4><p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复 bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>\n<h4 id=\"多人合作\"><a href=\"#多人合作\" class=\"headerlink\" title=\"多人合作\"></a>多人合作</h4><p><code>git push origin 分支名</code>推送分支到远程仓库</p>\n<h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><h3 id=\"添加远程库\"><a href=\"#添加远程库\" class=\"headerlink\" title=\"添加远程库\"></a>添加远程库</h3><p>登陆 GitHub，然后，在右上角找到“Create a new repo”按钮创建一个新的仓库，在 Repository name 填入仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库。<br>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；<br>关联后，使用命令<code>git push -u origin master</code>第一次推送 master 分支的所有内容；<br>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。如果推送失败,先用<code>git pull</code>抓取远程的新提交。</p>\n<h3 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆\"></a>从远程库克隆</h3><p>假设从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆 GitHub，创建一个新的仓库<br><code>git clone git@github.com:WangCheng96/webStudy.git</code></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>1、查看远程库信息，使用<code>git remote -v</code>。<br>2、在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致。<br>3、建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>。<br>4、从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>\n<h2 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h2><h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><p><code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为 HEAD，也可以指定一个 commit id；<br><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；<br><code>git tag</code>可以查看所有标签。</p>\n<h3 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h3><p><code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；<br><code>git push origin --tags</code>可以推送全部未推送过的本地标签；<br><code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；<br><code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>\n<h2 id=\"用-Git-Subtree-在多个-Git-项目间双向同步子项目\"><a href=\"#用-Git-Subtree-在多个-Git-项目间双向同步子项目\" class=\"headerlink\" title=\"用 Git Subtree 在多个 Git 项目间双向同步子项目\"></a>用 Git Subtree 在多个 Git 项目间双向同步子项目</h2><h3 id=\"什么时候需要-Subtree\"><a href=\"#什么时候需要-Subtree\" class=\"headerlink\" title=\"什么时候需要 Subtree\"></a>什么时候需要 Subtree</h3><ul>\n<li>当多个项目共用同一坨代码，而这坨代码跟着项目在快速更新的时候</li>\n<li>把一部分代码迁移出去独立为一个新的 git 仓库，但又希望能够保留这部分代码的历史提交记录。</li>\n</ul>\n"},{"title":"RESTful API","date":"2021-05-14T05:49:48.000Z","_content":"\n## REST\n\n### REST是什么\n\n- 万维网软件架构**风格**\n- 用来创建网络服务\n\n### 为何叫REST\n\n{% note success %}\nRepresentational State Transfer\n{% endnote %}\n\n- `Representational`：数据的表现形式（JSON、XML...）\n- `State`：当前状态或者数据\n- `Transfer`：数据传输\n\n### REST的6个限制\n\n客户-服务器（Client-Server）\n\n- 关注点分离\n- 服务器专注数据存储，提升了简单性\n- 前端专注用户界面，提升了可移植性\n\n无状态\n\n{% note primary %}\nJWT和Session的选择，JWT是无状态的\n{% endnote %}\n\n- 所有用户回话信息都保存在客户端\n- 每次请求必须包括所有信息，不能依赖上下文信息\n- 服务端不用保存会话信息，提升了简单性、可靠性、可见性\n\n缓存（Cache）\n\n- 所有服务端响应都要被标为可缓存或不可缓存\n- 减少前后端交互，提升了性能\n\n统一接口（Uniform Interface）\n\n- 接口设计尽可能统一通用，提升了简单性、可见性\n- 接口与实现解耦，使前后端可以独立开发迭代\n\n分层系统（Layered System）\n\n- 每层只知道相邻的一层，后面隐藏的就不知道了\n- 客户端不知道是和代理还是真实服务器通信\n- 其它层：安全层、负载均衡、缓存层等\n\n按需代码（Code-On-Demand可选）\n\n- 客户端可以下载运行服务端传来的代码（比如JS）\n- 通过减少一些功能，简化了客户端\n\n### 统一接口的限制\n\n资源的标识\n\n- 资源是任何可以命名的事务，比如用户、评论等\n- 每个资源可以通过URI被唯一地识别\n  - `http://api.github.com/users`\n  - `http://api.github.com/users/123`\n\n通过表述来操作资源\n\n- 表述就是`Representation`，比如JSON、XML等\n- 客户端不能直接操作（比如SQL）服务器资源\n- 客户端应该通过表述（比如JSON）来操作资源\n\n自描述消息\n\n- 每个消息（请求或响应）必须提供足够的信息让接受者理解\n- 媒体类型（application/json、application/xml）\n- HTTP方法：GET（查）、POST（增）、DELETE（删）\n- 是否缓存：Cache-Control\n\n超媒体作为应用状态引擎\n\n- 超媒体：带文字的链接\n- 应用状态：一个网页\n- 引擎：驱动、跳转\n- 合起来：点击链接跳转到另一个网页\n\n## RESTful API\n\n### 什么是RESTful API\n\n符合`REST`架构风格的API。\n\n### RESTful API 构成\n\n- 基本的URI，如`https://api.github.com/users`\n- 标准的HTTP方法，如GET、POST、PUT、PATCH、DELETE\n- 传输的数据媒体类型，如JSON、XML\n\n举例：\n\n- GET /users #获取user列表\n- GET /users/12 #查看某个具体的user\n- POST /users #新建一个user\n- PUT /users/12 #更新user 12\n- DELETE /users/12 #删除user 12\n\n### RESTful API设计最佳实践\n\n#### 请求设计规范\n\n- URI使用名词，尽量用复数，如/users\n- URI使用嵌套表示关联关系，如/users/12/repos/5\n- 使用正确的HTTP方法，如GET/POST/PUT/DELETE\n- 不符合CRUD的情况：POST/action/子资源\n\n#### 响应设计规范\n\n- 查询\n- 分页\n- 字段过滤\n- 状态码\n- 错误处理\n\n#### 安全\n\n- HTTPS\n- 鉴权\n- 限流\n\n#### 开发者友好\n\n- 文档\n- 超媒体\n\n#### 增删改查应该返回什么响应\n\n- 增、改：当前增加或修改的数据\n- 查：查询的数据\n- 删：返回204\n\n#### 字段过滤\n\n`GET https://localhost:3000/user/1?fields=name;age`;\n\n#### 嵌套结构\n\n- 查看关注列表\n  `GET https://localhost:3000/:id/folowing`\n\n- 添加关注\n  `PUT https://localhost:3000/flowing/:id`\n\n- 回复文章评论\n  `POST https://localhost:3000/questions/:questionId/answers/:answerId/comments`\n","source":"_posts/RESTful-API.md","raw":"---\ntitle: RESTful API\ndate: 2021-05-14 13:49:48\ntags: [RESTful API]\n---\n\n## REST\n\n### REST是什么\n\n- 万维网软件架构**风格**\n- 用来创建网络服务\n\n### 为何叫REST\n\n{% note success %}\nRepresentational State Transfer\n{% endnote %}\n\n- `Representational`：数据的表现形式（JSON、XML...）\n- `State`：当前状态或者数据\n- `Transfer`：数据传输\n\n### REST的6个限制\n\n客户-服务器（Client-Server）\n\n- 关注点分离\n- 服务器专注数据存储，提升了简单性\n- 前端专注用户界面，提升了可移植性\n\n无状态\n\n{% note primary %}\nJWT和Session的选择，JWT是无状态的\n{% endnote %}\n\n- 所有用户回话信息都保存在客户端\n- 每次请求必须包括所有信息，不能依赖上下文信息\n- 服务端不用保存会话信息，提升了简单性、可靠性、可见性\n\n缓存（Cache）\n\n- 所有服务端响应都要被标为可缓存或不可缓存\n- 减少前后端交互，提升了性能\n\n统一接口（Uniform Interface）\n\n- 接口设计尽可能统一通用，提升了简单性、可见性\n- 接口与实现解耦，使前后端可以独立开发迭代\n\n分层系统（Layered System）\n\n- 每层只知道相邻的一层，后面隐藏的就不知道了\n- 客户端不知道是和代理还是真实服务器通信\n- 其它层：安全层、负载均衡、缓存层等\n\n按需代码（Code-On-Demand可选）\n\n- 客户端可以下载运行服务端传来的代码（比如JS）\n- 通过减少一些功能，简化了客户端\n\n### 统一接口的限制\n\n资源的标识\n\n- 资源是任何可以命名的事务，比如用户、评论等\n- 每个资源可以通过URI被唯一地识别\n  - `http://api.github.com/users`\n  - `http://api.github.com/users/123`\n\n通过表述来操作资源\n\n- 表述就是`Representation`，比如JSON、XML等\n- 客户端不能直接操作（比如SQL）服务器资源\n- 客户端应该通过表述（比如JSON）来操作资源\n\n自描述消息\n\n- 每个消息（请求或响应）必须提供足够的信息让接受者理解\n- 媒体类型（application/json、application/xml）\n- HTTP方法：GET（查）、POST（增）、DELETE（删）\n- 是否缓存：Cache-Control\n\n超媒体作为应用状态引擎\n\n- 超媒体：带文字的链接\n- 应用状态：一个网页\n- 引擎：驱动、跳转\n- 合起来：点击链接跳转到另一个网页\n\n## RESTful API\n\n### 什么是RESTful API\n\n符合`REST`架构风格的API。\n\n### RESTful API 构成\n\n- 基本的URI，如`https://api.github.com/users`\n- 标准的HTTP方法，如GET、POST、PUT、PATCH、DELETE\n- 传输的数据媒体类型，如JSON、XML\n\n举例：\n\n- GET /users #获取user列表\n- GET /users/12 #查看某个具体的user\n- POST /users #新建一个user\n- PUT /users/12 #更新user 12\n- DELETE /users/12 #删除user 12\n\n### RESTful API设计最佳实践\n\n#### 请求设计规范\n\n- URI使用名词，尽量用复数，如/users\n- URI使用嵌套表示关联关系，如/users/12/repos/5\n- 使用正确的HTTP方法，如GET/POST/PUT/DELETE\n- 不符合CRUD的情况：POST/action/子资源\n\n#### 响应设计规范\n\n- 查询\n- 分页\n- 字段过滤\n- 状态码\n- 错误处理\n\n#### 安全\n\n- HTTPS\n- 鉴权\n- 限流\n\n#### 开发者友好\n\n- 文档\n- 超媒体\n\n#### 增删改查应该返回什么响应\n\n- 增、改：当前增加或修改的数据\n- 查：查询的数据\n- 删：返回204\n\n#### 字段过滤\n\n`GET https://localhost:3000/user/1?fields=name;age`;\n\n#### 嵌套结构\n\n- 查看关注列表\n  `GET https://localhost:3000/:id/folowing`\n\n- 添加关注\n  `PUT https://localhost:3000/flowing/:id`\n\n- 回复文章评论\n  `POST https://localhost:3000/questions/:questionId/answers/:answerId/comments`\n","slug":"RESTful-API","published":1,"updated":"2021-05-20T06:20:49.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr90alo00002as7ibakphdhc","content":"<h2 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a>REST</h2><h3 id=\"REST是什么\"><a href=\"#REST是什么\" class=\"headerlink\" title=\"REST是什么\"></a>REST是什么</h3><ul>\n<li>万维网软件架构<strong>风格</strong></li>\n<li>用来创建网络服务</li>\n</ul>\n<h3 id=\"为何叫REST\"><a href=\"#为何叫REST\" class=\"headerlink\" title=\"为何叫REST\"></a>为何叫REST</h3><div class=\"note note-success\">\n            <p>Representational State Transfer</p>\n          </div>\n\n<ul>\n<li><code>Representational</code>：数据的表现形式（JSON、XML…）</li>\n<li><code>State</code>：当前状态或者数据</li>\n<li><code>Transfer</code>：数据传输</li>\n</ul>\n<h3 id=\"REST的6个限制\"><a href=\"#REST的6个限制\" class=\"headerlink\" title=\"REST的6个限制\"></a>REST的6个限制</h3><p>客户-服务器（Client-Server）</p>\n<ul>\n<li>关注点分离</li>\n<li>服务器专注数据存储，提升了简单性</li>\n<li>前端专注用户界面，提升了可移植性</li>\n</ul>\n<p>无状态</p>\n<div class=\"note note-primary\">\n            <p>JWT和Session的选择，JWT是无状态的</p>\n          </div>\n\n<ul>\n<li>所有用户回话信息都保存在客户端</li>\n<li>每次请求必须包括所有信息，不能依赖上下文信息</li>\n<li>服务端不用保存会话信息，提升了简单性、可靠性、可见性</li>\n</ul>\n<p>缓存（Cache）</p>\n<ul>\n<li>所有服务端响应都要被标为可缓存或不可缓存</li>\n<li>减少前后端交互，提升了性能</li>\n</ul>\n<p>统一接口（Uniform Interface）</p>\n<ul>\n<li>接口设计尽可能统一通用，提升了简单性、可见性</li>\n<li>接口与实现解耦，使前后端可以独立开发迭代</li>\n</ul>\n<p>分层系统（Layered System）</p>\n<ul>\n<li>每层只知道相邻的一层，后面隐藏的就不知道了</li>\n<li>客户端不知道是和代理还是真实服务器通信</li>\n<li>其它层：安全层、负载均衡、缓存层等</li>\n</ul>\n<p>按需代码（Code-On-Demand可选）</p>\n<ul>\n<li>客户端可以下载运行服务端传来的代码（比如JS）</li>\n<li>通过减少一些功能，简化了客户端</li>\n</ul>\n<h3 id=\"统一接口的限制\"><a href=\"#统一接口的限制\" class=\"headerlink\" title=\"统一接口的限制\"></a>统一接口的限制</h3><p>资源的标识</p>\n<ul>\n<li>资源是任何可以命名的事务，比如用户、评论等</li>\n<li>每个资源可以通过URI被唯一地识别<ul>\n<li><code>http://api.github.com/users</code></li>\n<li><code>http://api.github.com/users/123</code></li>\n</ul>\n</li>\n</ul>\n<p>通过表述来操作资源</p>\n<ul>\n<li>表述就是<code>Representation</code>，比如JSON、XML等</li>\n<li>客户端不能直接操作（比如SQL）服务器资源</li>\n<li>客户端应该通过表述（比如JSON）来操作资源</li>\n</ul>\n<p>自描述消息</p>\n<ul>\n<li>每个消息（请求或响应）必须提供足够的信息让接受者理解</li>\n<li>媒体类型（application/json、application/xml）</li>\n<li>HTTP方法：GET（查）、POST（增）、DELETE（删）</li>\n<li>是否缓存：Cache-Control</li>\n</ul>\n<p>超媒体作为应用状态引擎</p>\n<ul>\n<li>超媒体：带文字的链接</li>\n<li>应用状态：一个网页</li>\n<li>引擎：驱动、跳转</li>\n<li>合起来：点击链接跳转到另一个网页</li>\n</ul>\n<h2 id=\"RESTful-API\"><a href=\"#RESTful-API\" class=\"headerlink\" title=\"RESTful API\"></a>RESTful API</h2><h3 id=\"什么是RESTful-API\"><a href=\"#什么是RESTful-API\" class=\"headerlink\" title=\"什么是RESTful API\"></a>什么是RESTful API</h3><p>符合<code>REST</code>架构风格的API。</p>\n<h3 id=\"RESTful-API-构成\"><a href=\"#RESTful-API-构成\" class=\"headerlink\" title=\"RESTful API 构成\"></a>RESTful API 构成</h3><ul>\n<li>基本的URI，如<code>https://api.github.com/users</code></li>\n<li>标准的HTTP方法，如GET、POST、PUT、PATCH、DELETE</li>\n<li>传输的数据媒体类型，如JSON、XML</li>\n</ul>\n<p>举例：</p>\n<ul>\n<li>GET /users #获取user列表</li>\n<li>GET /users/12 #查看某个具体的user</li>\n<li>POST /users #新建一个user</li>\n<li>PUT /users/12 #更新user 12</li>\n<li>DELETE /users/12 #删除user 12</li>\n</ul>\n<h3 id=\"RESTful-API设计最佳实践\"><a href=\"#RESTful-API设计最佳实践\" class=\"headerlink\" title=\"RESTful API设计最佳实践\"></a>RESTful API设计最佳实践</h3><h4 id=\"请求设计规范\"><a href=\"#请求设计规范\" class=\"headerlink\" title=\"请求设计规范\"></a>请求设计规范</h4><ul>\n<li>URI使用名词，尽量用复数，如/users</li>\n<li>URI使用嵌套表示关联关系，如/users/12/repos/5</li>\n<li>使用正确的HTTP方法，如GET/POST/PUT/DELETE</li>\n<li>不符合CRUD的情况：POST/action/子资源</li>\n</ul>\n<h4 id=\"响应设计规范\"><a href=\"#响应设计规范\" class=\"headerlink\" title=\"响应设计规范\"></a>响应设计规范</h4><ul>\n<li>查询</li>\n<li>分页</li>\n<li>字段过滤</li>\n<li>状态码</li>\n<li>错误处理</li>\n</ul>\n<h4 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h4><ul>\n<li>HTTPS</li>\n<li>鉴权</li>\n<li>限流</li>\n</ul>\n<h4 id=\"开发者友好\"><a href=\"#开发者友好\" class=\"headerlink\" title=\"开发者友好\"></a>开发者友好</h4><ul>\n<li>文档</li>\n<li>超媒体</li>\n</ul>\n<h4 id=\"增删改查应该返回什么响应\"><a href=\"#增删改查应该返回什么响应\" class=\"headerlink\" title=\"增删改查应该返回什么响应\"></a>增删改查应该返回什么响应</h4><ul>\n<li>增、改：当前增加或修改的数据</li>\n<li>查：查询的数据</li>\n<li>删：返回204</li>\n</ul>\n<h4 id=\"字段过滤\"><a href=\"#字段过滤\" class=\"headerlink\" title=\"字段过滤\"></a>字段过滤</h4><p><code>GET https://localhost:3000/user/1?fields=name;age</code>;</p>\n<h4 id=\"嵌套结构\"><a href=\"#嵌套结构\" class=\"headerlink\" title=\"嵌套结构\"></a>嵌套结构</h4><ul>\n<li><p>查看关注列表<br><code>GET https://localhost:3000/:id/folowing</code></p>\n</li>\n<li><p>添加关注<br><code>PUT https://localhost:3000/flowing/:id</code></p>\n</li>\n<li><p>回复文章评论<br><code>POST https://localhost:3000/questions/:questionId/answers/:answerId/comments</code></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a>REST</h2><h3 id=\"REST是什么\"><a href=\"#REST是什么\" class=\"headerlink\" title=\"REST是什么\"></a>REST是什么</h3><ul>\n<li>万维网软件架构<strong>风格</strong></li>\n<li>用来创建网络服务</li>\n</ul>\n<h3 id=\"为何叫REST\"><a href=\"#为何叫REST\" class=\"headerlink\" title=\"为何叫REST\"></a>为何叫REST</h3><div class=\"note note-success\">\n            <p>Representational State Transfer</p>\n          </div>\n\n<ul>\n<li><code>Representational</code>：数据的表现形式（JSON、XML…）</li>\n<li><code>State</code>：当前状态或者数据</li>\n<li><code>Transfer</code>：数据传输</li>\n</ul>\n<h3 id=\"REST的6个限制\"><a href=\"#REST的6个限制\" class=\"headerlink\" title=\"REST的6个限制\"></a>REST的6个限制</h3><p>客户-服务器（Client-Server）</p>\n<ul>\n<li>关注点分离</li>\n<li>服务器专注数据存储，提升了简单性</li>\n<li>前端专注用户界面，提升了可移植性</li>\n</ul>\n<p>无状态</p>\n<div class=\"note note-primary\">\n            <p>JWT和Session的选择，JWT是无状态的</p>\n          </div>\n\n<ul>\n<li>所有用户回话信息都保存在客户端</li>\n<li>每次请求必须包括所有信息，不能依赖上下文信息</li>\n<li>服务端不用保存会话信息，提升了简单性、可靠性、可见性</li>\n</ul>\n<p>缓存（Cache）</p>\n<ul>\n<li>所有服务端响应都要被标为可缓存或不可缓存</li>\n<li>减少前后端交互，提升了性能</li>\n</ul>\n<p>统一接口（Uniform Interface）</p>\n<ul>\n<li>接口设计尽可能统一通用，提升了简单性、可见性</li>\n<li>接口与实现解耦，使前后端可以独立开发迭代</li>\n</ul>\n<p>分层系统（Layered System）</p>\n<ul>\n<li>每层只知道相邻的一层，后面隐藏的就不知道了</li>\n<li>客户端不知道是和代理还是真实服务器通信</li>\n<li>其它层：安全层、负载均衡、缓存层等</li>\n</ul>\n<p>按需代码（Code-On-Demand可选）</p>\n<ul>\n<li>客户端可以下载运行服务端传来的代码（比如JS）</li>\n<li>通过减少一些功能，简化了客户端</li>\n</ul>\n<h3 id=\"统一接口的限制\"><a href=\"#统一接口的限制\" class=\"headerlink\" title=\"统一接口的限制\"></a>统一接口的限制</h3><p>资源的标识</p>\n<ul>\n<li>资源是任何可以命名的事务，比如用户、评论等</li>\n<li>每个资源可以通过URI被唯一地识别<ul>\n<li><code>http://api.github.com/users</code></li>\n<li><code>http://api.github.com/users/123</code></li>\n</ul>\n</li>\n</ul>\n<p>通过表述来操作资源</p>\n<ul>\n<li>表述就是<code>Representation</code>，比如JSON、XML等</li>\n<li>客户端不能直接操作（比如SQL）服务器资源</li>\n<li>客户端应该通过表述（比如JSON）来操作资源</li>\n</ul>\n<p>自描述消息</p>\n<ul>\n<li>每个消息（请求或响应）必须提供足够的信息让接受者理解</li>\n<li>媒体类型（application/json、application/xml）</li>\n<li>HTTP方法：GET（查）、POST（增）、DELETE（删）</li>\n<li>是否缓存：Cache-Control</li>\n</ul>\n<p>超媒体作为应用状态引擎</p>\n<ul>\n<li>超媒体：带文字的链接</li>\n<li>应用状态：一个网页</li>\n<li>引擎：驱动、跳转</li>\n<li>合起来：点击链接跳转到另一个网页</li>\n</ul>\n<h2 id=\"RESTful-API\"><a href=\"#RESTful-API\" class=\"headerlink\" title=\"RESTful API\"></a>RESTful API</h2><h3 id=\"什么是RESTful-API\"><a href=\"#什么是RESTful-API\" class=\"headerlink\" title=\"什么是RESTful API\"></a>什么是RESTful API</h3><p>符合<code>REST</code>架构风格的API。</p>\n<h3 id=\"RESTful-API-构成\"><a href=\"#RESTful-API-构成\" class=\"headerlink\" title=\"RESTful API 构成\"></a>RESTful API 构成</h3><ul>\n<li>基本的URI，如<code>https://api.github.com/users</code></li>\n<li>标准的HTTP方法，如GET、POST、PUT、PATCH、DELETE</li>\n<li>传输的数据媒体类型，如JSON、XML</li>\n</ul>\n<p>举例：</p>\n<ul>\n<li>GET /users #获取user列表</li>\n<li>GET /users/12 #查看某个具体的user</li>\n<li>POST /users #新建一个user</li>\n<li>PUT /users/12 #更新user 12</li>\n<li>DELETE /users/12 #删除user 12</li>\n</ul>\n<h3 id=\"RESTful-API设计最佳实践\"><a href=\"#RESTful-API设计最佳实践\" class=\"headerlink\" title=\"RESTful API设计最佳实践\"></a>RESTful API设计最佳实践</h3><h4 id=\"请求设计规范\"><a href=\"#请求设计规范\" class=\"headerlink\" title=\"请求设计规范\"></a>请求设计规范</h4><ul>\n<li>URI使用名词，尽量用复数，如/users</li>\n<li>URI使用嵌套表示关联关系，如/users/12/repos/5</li>\n<li>使用正确的HTTP方法，如GET/POST/PUT/DELETE</li>\n<li>不符合CRUD的情况：POST/action/子资源</li>\n</ul>\n<h4 id=\"响应设计规范\"><a href=\"#响应设计规范\" class=\"headerlink\" title=\"响应设计规范\"></a>响应设计规范</h4><ul>\n<li>查询</li>\n<li>分页</li>\n<li>字段过滤</li>\n<li>状态码</li>\n<li>错误处理</li>\n</ul>\n<h4 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h4><ul>\n<li>HTTPS</li>\n<li>鉴权</li>\n<li>限流</li>\n</ul>\n<h4 id=\"开发者友好\"><a href=\"#开发者友好\" class=\"headerlink\" title=\"开发者友好\"></a>开发者友好</h4><ul>\n<li>文档</li>\n<li>超媒体</li>\n</ul>\n<h4 id=\"增删改查应该返回什么响应\"><a href=\"#增删改查应该返回什么响应\" class=\"headerlink\" title=\"增删改查应该返回什么响应\"></a>增删改查应该返回什么响应</h4><ul>\n<li>增、改：当前增加或修改的数据</li>\n<li>查：查询的数据</li>\n<li>删：返回204</li>\n</ul>\n<h4 id=\"字段过滤\"><a href=\"#字段过滤\" class=\"headerlink\" title=\"字段过滤\"></a>字段过滤</h4><p><code>GET https://localhost:3000/user/1?fields=name;age</code>;</p>\n<h4 id=\"嵌套结构\"><a href=\"#嵌套结构\" class=\"headerlink\" title=\"嵌套结构\"></a>嵌套结构</h4><ul>\n<li><p>查看关注列表<br><code>GET https://localhost:3000/:id/folowing</code></p>\n</li>\n<li><p>添加关注<br><code>PUT https://localhost:3000/flowing/:id</code></p>\n</li>\n<li><p>回复文章评论<br><code>POST https://localhost:3000/questions/:questionId/answers/:answerId/comments</code></p>\n</li>\n</ul>\n"},{"title":"计算机网络","date":"2020-03-27T10:44:43.000Z","_content":"\n## 概述\n\n计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。\n\n按分布范围，计算机网络里有`局域网LAN`和`广域网WAN`, 其中局域网的代表以太网，以及这两种网络最重要的区分点，局域网基于`广播技术`，广域网基于`分组交换`技术。\n\n### 网络的网络\n\n网络把主机连接起来，而互连网`internet`是把多种不同的网络连接起来，因此互连网是网络的网络。而英特网`Internet`是全球范围的互连网。\n\n### ISP\n\n{% note primary %}\nISP (Internet service provider) 互联网服务提供商\n{% endnote %}\n\n`ISP`可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向`ISP`缴纳一定的费用就可以接入互联网。\n\n目前的互联网是一种多层次`ISP`结构，`ISP`根据覆盖面积的大小分为第一层`ISP`、区域`ISP`和接入`ISP`。互联网交换点 IXP 允许两个`ISP`直接相连而不用经过第三个`ISP`。\n\n### 主机之间的通信方式\n\n- 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。\n- 对等（P2P）：不区分客户和服务器。\n\n### 电路交换与分组交换\n\n- 电路交换\n\n  电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。\n\n- 分组交换\n\n  每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。\n\n在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。\n\n### 衡量计算机网络的性能的指标\n\n#### 速率\n\n速率就是数据传输（数据是指 0 和 1）的速率，比如用迅雷下载，1 兆每秒，来衡量目前数据传输的快慢。它是计算机网络中最重要的一个性能指标。\n\n#### 带宽\n\n在计算机网络中，网络带宽是指在单位时间（一般指的是 1 秒钟）内能传输的数据量，比如说你家的电信网络是 100 兆比特，意思是，一秒内最大的传输速率是 100 兆比特。\n\n#### 吞吐量\n\n吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。\n\n{% note primary %}\n由此可知带宽说的是最大值速率，吞吐量说的是某时刻速率。但吞吐量不能超过最大速率\n{% endnote %}\n\n#### 时延\n\n时延是指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。单位是 s。 时延分以下几种：\n\n- 排队时延：分组在经过网络传输时，要经过很多的`路由器`。但分组在进入路由器后要先在输入队列中`排队等待`处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发，这就产生了`排队时延`。排队时延的长短往往却决于网络当时的通信量，当网络的通信量很大时会发生排队溢出，是`分组丢失`。\n- 处理时延：`路由器`或`主机`在收到数据报时，要花费一定时间进行处理，例如`分析数据报的首部`、进行`首部差错检验`，`查找路由表`为数据报选定准发接口，这就产生了处理时延。\n- 发送时延：主机或路由器传输数据帧所需要的时间。\n- 传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。\n\n{% note primary %}\n总时延 = 排队时延 + 处理时延 + 发送时延 + 传播时延\n{% endnote %}\n\n#### 往返时间（RTT）\n\n在计算机网络中，往返时间也是一个重要的性能指标，它表示从发送方发送数据开始，到发送方收到来自接收方的确认（接受方收到数据后便立即发送确认）总共经历的时间。\n\n#### 时延带宽积\n\n是指传播时延乘以带宽。\n\n### 计算机网络体系结构\n\n![计算机网络体系结构](/img/notes/2020-3-27_1_32.png)\n\n#### 五层协议\n\n- 应用层：为特定应用程序提供数据传输服务，例如`HTTP`、`DNS`等协议。数据单位为报文。\n- 传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议`TCP`，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 `UDP`，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。`TCP`主要提供完整性服务，`UDP`主要提供及时性服务。\n- 网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。\n- 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。\n- 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n\n#### OSI\n\n{% note primary %}\nOSI (Open System Interconnection Model)\n{% endnote %}\n\n如下图所示，1、2、3 层主要是`物理链路`组成的，比如`光纤`，`路由器`，`集线器`，主要负责的是`数据通信`。5、6、7 层是`软件控制`的，比如`HTTP`协议，是一种软件层面控制的协议，主要负责处理传输来的`数据`。\n\n![OSI](/img/notes/2020-3-27_1_1.png)\n\n其中表示层和会话层用途如下:\n\n- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。\n\n- 会话层：建立及管理会话。\n\n五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。\n\n#### TCP/IP\n\n它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。\n\n`TCP/IP`体系结构不严格遵循`OSI`分层概念，应用层可能会直接使用IP层或者网络接口层。\n\n#### 数据在各层之间的传递过程\n\n在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。\n\n路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。\n\n## 物理层\n\n### 物理层作用\n\n对于物理层，有人会说，这不就是网线吗，比如家里连接路由器的网线，电线杆上的光纤？其实不然，物理层更多的是规定一种标准，他并不管物理介质具体是什么，比如电线杆上是光纤还是双绞线，只要你能按物理层规定的标准传输数据就行。\n\n{% note primary %}\n物理层是规定传输媒体接口的标准\n{% endnote %}\n\n### 通信方式\n\n根据信息在传输线上的传送方向，分为以下三种通信方式：\n\n- 单工通信：单向传输。\n- 半双工通信：双向交替传输。是指允许数据在两个方向上传输，但是在某一时刻只允许数据在一个方向上传输。\n- 全双工通信：双向同时传输。\n\n### 光纤宽带上网的传输数据形式\n\n- 首先计算机网卡传输出来的数据是`电信号`，光纤传输的是`光脉冲`信号，有光脉冲表示`1`，无光脉冲表示`0`。\n- 而可见光的频率大约是`10的8次方MHz`，因此光纤通信系统的带宽远远大于其它各种传输媒体的带宽\n- 所以我们计算机传输数据需要先把`电信号`转为`光信号`，然后`光信号`快到服务器的时候，再把`光信号`转为`电信号`。\n\n### 物理层设备中继器\n\n为什么需要中继器呢？因为再线路上传输的信号功率会`逐渐衰减`，衰减到一定程度时将造成`信号失真`，因此会导致接收错误。中继器可以对信号进行`再生`和`还原`，增加信号的传输距离。\n\n需要注意的是，中继器两端连接不同的网段，而不是子网。\n\n## 数据链路层\n\n### 主要功能\n\n- 封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。封装的网络数据报，在链路层就叫`数据帧`。\n- 透明传输：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。\n- 差错控制：在文件送到 B 公司小秘书手里的时候，快递包上写着 5 个文件，秘书一看只有 3 个文件，就会让物理层重新发送有没有送到的文件。目前数据链路层广泛使用了`CRC循环冗余检验`来检查比特差错。\n- 差错纠正：链路层知道 1，2，3，4，5 个文件，丢失的两个文件到底是哪两个，并且能通过重新发送没有的文件来纠正。\n- 流量控制：比如说发送方发送速度特别快，接收方接收速度特别慢，会造成传输出错。\n\n这里需要注意的是，传输层 TCP 也有流量控制功能，区别在于 TCP 是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）流量控制的方法有滑动窗口协议，以及选择重传协议。\n\n### 通信分类\n\n#### 广播信道\n\n一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。\n\n所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。\n\n主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。\n\n#### 点对点信道\n\n一对一通信。\n\n因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。\n\n### CSMA/CD 协议\n\n`CSMA/CD`表示载波监听多点接入/碰撞检测。\n\n- 多点接入：说明这是总线型网络（半双工），许多主机以多点的方式连接到总线上。\n- 载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。\n- 碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。\n\n### PPP 协议\n\n互联网用户通常需要连接到某个`ISP`之后才能接入到互联网，`PPP`协议是用户计算机和`ISP`进行通信时所使用的数据链路层协议。\n\nPPP 的帧格式：\n\n- F 字段为帧的定界符\n- A 和 C 字段暂时没有意义\n- FCS 字段是使用 CRC 的检验序列\n- 信息部分的长度不超过 1500\n\n### MAC地址\n\n`MAC地址`是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。\n\n一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。\n\n### 局域网\n\n局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。\n\n主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。\n\n可以按照网络拓扑结构对局域网进行分类：\n\n![局域网拓扑结构](/img/notes/2020-3-27_1_33.png)\n\n### 以太网\n\n以太网是一种`局域网`技术，其规定了`访问控制方法`、`传输控制协议`、`网络拓扑结构`、`传输速率`等，完成数据链路层和物理层的一些内容，它采用一种称作`CSMA/CD`的媒体接入方法，另外的一些局域网技术，比如无线局域网等。\n\n#### 以太网的帧格式\n\n![以太网的帧格式](/img/notes/2020-3-27_1_2.png)\n\n- 其中`目的地址`和`源地址`指的是`MAC地址`，即设备的物理地址。`MAC地址`用于标示网卡，每个网卡都具有唯一的`MAC地址`。\n- 当在同一个局域网中，主机`A`需要给主机`B`发送消息时，主机`A`将以太网帧发出，此时局域网中所有主机均可收到这个桢，主机中的网卡接收到以太网桢后，会将目的`MAC地址`和自己的`MAC地址`进行比较,如果不相同就会丢弃，如果相同则会接收，此时则`Ｂ`主机就收到了`Ａ`的消息。\n- 其最后面是`CRC循环冗余码`，用于差错控制，即检验帧的正确性。\n- 在以太网协议中，目的地址分为三种`单播地址`、`广播地址`、`多播地址`，其中`单播地址`如上面`Ａ`给`Ｂ`主机发送，其接收者为一个，并且其目的地址的最高字节的低位为`0`。\n\n#### 以太网的特点\n\n- 无连接。发送方和接收方不建立连接。\n- 不可靠。接收方不向发送方进行确认，差错帧直接丢弃。\n\n#### 以太网的拓扑结构\n\n跟以太网相关的拓扑结构有`星型`和`总线型`。\n\n互联网初期，以太网的`总线型拓扑`比较普遍。随着总线型以太网上的站点数目增多,`可靠性也会随之下降`,而随着大规模集成电路以及专门芯片的发展,使得`星型以太网变得便宜又可靠`。\n\n需要注意的是，以太网虽然物理上是`星型拓扑`，但逻辑上是`总线型`。\n\n### 网卡\n\n计算机传出的数据，经过网卡，就会变为`以太网的帧`，还会完成一些`链路管理`（CSMA/CD 的实现），以及`编码`和`译码`。\n\n### 无线局域网\n\n无线局域网 WLAN 是利用无线电波、激光和红外线等无线通信技术来构建的局域网。\n\n### 链路层的设备\n\n#### 网桥\n\n网桥根据`MAC帧`的目的地址进行转发和过滤。当网桥收到一个帧时，并不会向所有接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个口，或者是把它丢弃。\n\n这里需要注意的是，网桥连接的是不同的网段.\n\n#### 交换机\n\n谈到交换机，就不得不提两个概念，`冲突域`和`广播域`\n\n- 冲突域： 是指同一时间只能由一台设备发送信息的范围。\n- 广播域：如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为广播域\n\n也就是说，广播域可以跨网段，而冲突域只是发生的同一个网段。\n\n举个例子，公司里大家的电脑一般都是连接到交换机上，因为交换机可以隔离冲突域，冲突域的最大问题在于，同一时间只能有一台机器传输数据，公司那么多人，如果这样的话，传输数据速度太慢了。然后交换机再连接到路由器上，首先路由器能隔离广播域，其次不经过路由器，你的数据链路层上的包没办法进入到互联网里面去，路由器是网络层的设备。\n\n交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。\n\n正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。\n\n下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。\n\n![交换机交换表](/img/notes/2020-3-27_1_3.png)\n\n## 网络层\n\n网络层主要任务是将`分组`从一台主机移动到另一台主机，从而提供了`主机到主机的通信服务`和各种形式的`进程到进程的通信`。\n\n分组：大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发动，这种小块就称作分组。\n\n### 分组交换\n\n当`主机H1`要向另一`主机H2`发送数据（报文）时，首先将数据划分成若干个等长的分组，然后将这些分组一个接一个地发往里与`H1`相联的`路由A`,当`A`接到分组后，先放入缓冲区，再按一定的路由算法确定该分组下一步将发注哪个结点，如此一个结点一个结点传递，直到最终目的`H2`。\n\n这一段话比较啰嗦，简单来说分组就是`分数据块`，同时还具有`无需建立连接`，存储转发（存储转发是指以太网交换机的控制器先将输入端口到来的数据报缓存起来，先检查数据报是否正确，并过滤掉冲突包错误），`动态分配路线`（交换设备会根据网络状况选择不同的路线，比如路由器）的优点。\n\n### 数据报\n\n数据报是通过网络传输的`数据的基本单元`，包含一个`报头（header）`和`数据`本身。说白了，就是带地址的数据，比如你的写了一句微信\"你好\"，这串文字本上加上源地址，目的地址，就是数据报。\n\n### IP 数据报格式\n\n![IP数据报格式](/img/notes/2020-3-27_1_5.png)\n\n- 首部的**固定部分**是`20字节`，共 `20 * 8 = 160` 比特（1 字节=8 比特）。\n- **版本**：占4位，有 4（IPv4）和 6（IPv6）两个值。\n- **首部长度**：`单位是 4B`，最小为 5，因为首部至少 20 字节，所以 4 \\* 5 就是 20 字节。\n- **区分服务** ：用来获得更好的服务，一般情况下不使用。\n- **总长度**：首部长度+数据部分长度。\n- **标识**： 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。\n- **片偏移** ：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。\n- **生存时间**：`TTL`，它告诉网络，数据报在网络中的时间是否太长而应被丢弃。以路由器跳数为单位，每经过一个路由器减一，变成 0 就丢弃。\n- **协议**：是指数据部分用的什么协议，我们只需要知道`TCP`协议用`6`表示，`UDP`协议用`17`表示即可。\n- **首部校验和**：这个字段只检验数据报的首部，不包括数据部分，因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。\n- **目的地址**和**源地址**都是`IP地址`，目的地址是通过`DNS`查询得来的。\n\n### IP 分片\n\n为什么需要分片：链路层数据帧封装的数据大小是有限制的，以太网的 MTU（MTU 是指一种通信协议的某一层上面所能通过的最大数据报大小）是 1500 字节。\n\n在 IP 数据报上，标识了分片的数据的字段：\n\n![IP数据报格式](/img/notes/2020-3-27_1_7.png)\n\n- **标识**\n- **标志**：占 3 位，但只有两位有意义，第一个位叫`MF(More Fragment)`，MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。中间的一位记为`DF(Don’t Fragment)`，意思是“不能分片”。只有当 DF=0 时才允许分片。\n- **片偏移**：较长的分组在分片后，某片在原分组中的相对位置。\n\n![数据报的分片举例](/img/notes/2020-3-27_1_34.png)\n\n### IP 地址分类\n\n![IP地址分类](/img/notes/2020-3-27_1_6.png)\n\n其中`127.0.0.0~127.255.255.255`用于环回测试。\n\n有一部分叫`私有IP地址`，是不能拿到网络上跟别的计算机通信的。只能是局域网自己内部用。比如说有：\n\n![私有IP地址](/img/notes/2020-3-27_1_8.png)\n\n可以看到，C 类私有地址就是`192.168`网段，每个局域网都可以有这些私有 IP。\n\n还有一些`特殊地址`，需要了解：\n\n![特殊地址](/img/notes/2020-3-27_1_9.png)\n\n注意，这里的全 1 是指，IPV4 地址由 4 个字节组成，每一个字节是 8 位，8 位全一就是十进制的 255, 即`255.255.255.255`。\n\n- 第一行，全一，代表是`255.255.255.255`，在本网络的目的地址写这个的话，就会内网广播。\n- 第二行，网络号特定值，主机号是全 0，比如，`192.169.10.1`，这是 c 类网络，所以网络号是`192.169.10`，主机号是 1，当主机号全 0 时，就是 0，表示`192.169.10.0`这个网段。\n- 第三行，还是`192.169.10.1`这个 c 类地址，主机号都是 1，也就是 8 个 1，代表 255，所以 `192.169.10.255`表示本网段的广播地址。\n- 第四行，127 作为网络号，主机号非全 0 或 1，比如说`127.0.0.1`代表本机，称为环回地址。\n\nIPV4 中，`0.0.0.0`地址被用于表示一个无效的，未知的或者不可用的目标。在服务器中，`0.0.0.0`指的是本机上的所有 IPV4 地址，如果一个主机有两个 IP 地址，`192.168.1.1`和`10.1.2.1`，并且该主机上的一个服务监听的地址是`0.0.0.0`，那么通过两个 IP 地址都能够访问该服务。\n\n### 网络地址转换(NAT)\n\n在 IP 地址分类里面，我们知道私有 IP 地址是不能跟外网交互的，在小公司大多数计算机的地址都是`192.168`网段，都是私有 IP 地址，它是怎么跟外网交互数据的呢，这里就引出来一个知识点叫`网络地址转换NAT`。\n\n![网络地址转换NAT](/img/notes/2020-3-27_1_10.png)\n\n如上图所示，`192.168.0.3`，`192.168.0.4`都是私有网段上的，它们无法跟外网通信，这个时候由于路由器安装了 NAT 软件，就可以将自己的 IP 地址，即路由器的 IP 地址`172.38.1.5`作为内网的代理，去访问外网，外网返回来的数据，经过路由转换，转换成内网的`192.168`网段的私有地址。\n\n### 子网划分和子网掩码\n\n划分子网的方式是从网络的主机号借用若干位作为子网号，主机号也就相应减少了同样的位数。\n\n![子网划分](/img/notes/2020-3-27_1_11.png)\n\n当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。\n\n我们将`145.13.0.0`这个网段划分了三个子网，其中一个是`145.13.3.0`，一个是`145.13.21.0`，问题来了，如果一个数据报来了，数据报要交给的 IP 地址是`145.13.3.10`，我们怎么知道给哪个子网呢？\n\n方法是将数据报的目的地址，跟子网的子网掩码相与预算（二进制与预算规则是，1 跟 1 得 1，其它为 0），也就是目的地址`145.13.3.10`跟子网`145.13.3.0`的子网掩码`255.255.255.0`的与预算，得到的结果是`145.13.3.0`，所以发送到的子网就是`145.13.3.0`。\n\n### 地址解析协议ARP\n\n以太网的帧的格式：\n\n![以太网的帧格式](/img/notes/2020-3-27_1_2.png)\n\n上图有一个`源地址`和`目的地址`，这两个地址都是指的`MAC地址`，`MAC地址`是什么呢？简单说来就是两台相邻的路由器 A 和 B，A 怎么把数据传给 B 呢，它总要知道 B 的物理地址吧，物理地址就像门牌号一样，我要知道你住在哪里，才能把数据送过去吧？首先你肯定知道自己的`MAC地址`是多少，因为在网卡上有，问题在于，别人的`MAC地址`是多少？`ARP协议`就是来帮你找`MAC地址`的。\n\n#### ARP协议的过程\n\n![ARP协议的过程](/img/notes/2020-3-27_1_12.png)\n\n1. 每台主机都会在自己的`ARP缓冲区`中建立一个`ARP列表`，以表示 `IP地址`和`MAC地址`的映射关系\n2. 当源主机需要将一个数据报要发送到目的主机时，会首先检查自己`ARP列表`中是否存在该`IP地址`对应的 `MAC地址`\n3. 如果有，就直接将数据报发送到这个`MAC地址`；如果没有，就向本地网段发起一个 `ARP`请求的广播报，查询此目的主机对应的`MAC地址`\n4. 此`ARP`请求数据报里包括源主机的`IP地址`、`硬件地址`、以及`目的主机的IP地址`。网络中所有的主机收到这个`ARP请求`后，会检查数据报中的目的`IP`是否和自己的`IP地址`一致\n5. 如果不相同就忽略此数据报；如果相同，该主机首先将发送端的`MAC地址`和 `IP地址`添加到自己的`ARP列表`中\n6. 如果`ARP表`中已经存在该`IP`的信息，则将其覆盖，然后给源主机发送一个 `ARP响应数据报`，告诉对方自己是它需要查找的`MAC地址`\n7. 源主机收到这个`ARP响应数据报`后，将得到的目的主机的`IP地址`和`MAC地址`添加到自己的`ARP列表`中，并利用此信息开始数据的传输\n8. 如果源主机一直没有收到`ARP响应数据报`，表示`ARP查询失败`。\n\n### DHCP 协议\n\nDHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段 lP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。当接入局域网的时候，自动由这个 DHCP 服务器分配 IP，windows 用户可能知道网卡配置里面，有自动获取 IP 的功能，如果路由器提供 DHCP 服务，就会自动获取随机分配的 IP。路由器里可以开启这个服务。\n\n大致工作过程：\n\n![DHCP数据发送过程](/img/notes/2020-3-27_1_13.png)\n\n### 网际控制报文协议ICMP\n\n一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是 IP 协议并不提供可靠传输。如果丢包了，IP 协议并不能通知传输层是否丢包以及丢包的原因。\n\n所以我们就需要一种协议来完成这样的功能–`ICMP协议`。\n\n#### ICMP 协议主要功能\n\n- 确认 IP 报是否成功到达目标地址\n- 通知在发送过程中 IP 报被丢弃的原因，举一个例子：\n\n![ICMP应答报文](/img/notes/2020-3-27_1_14.png)\n\n主机 H2 收到主机 H1 的一个`UDP报`，结果 H2 发现这个报里的端口没有被监听，这时候就回复给 H2 一个`ICMP应答报文`，意思是这个`UDP数据报`无法交给应用进程，只能丢弃了。\n\n以下是 4 种常见的 ICMP 差错报告报文：\n\n![ICMP 差错报告报文](/img/notes/2020-3-27_1_15.png)\n\n我们常用的`PING`命令借助`ICMP协议`，探测主机是否能找到目的主机。\n\n### 网络设备路由器简介\n\n路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发和分组。\n\n如下图所示，分别有转发和分组功能的说明。\n\n![路由器功能](/img/notes/2020-3-27_1_16.png)\n\n接着，我们看一下路由器输入端口做了哪些事情：\n\n![路由器输入端口](/img/notes/2020-3-27_1_17.png)\n\n- 首先，物理层是傻瓜层，传输`比特流`，我们把物理层的比特流还原成`数据链路层`的`数据帧`，然后把`数据链路层`的`数据报`脱去，成为`网络层数据报`，交给路由器。这时候就要判断一下这个数据报是什么类型的了。\n\n- 如果它是路由器之间，交换路由信息的分组，就会把这个数据报交付给如上上图所示的，路由选择处理机，进行处理和计算。如果是数据分组，就会放到一个队列里面，排队等候，然后选择一个合适的输出端口输出。\n\n最后我们看一下路由器输出端口做了哪些事情：\n\n![路由器输出端口](/img/notes/2020-3-27_1_18.png)\n\n从上图可以看到，输出端口是做的输入端口的逆过程，将网络层的数据报转换为链路层的数据帧，最后转为物理层的比特流。\n\n> 输入和输出端口需要注意的是，它们都有一个缓冲队列，比如输入数据的速度太快，输出数据速度慢，为了平衡输入输出速度，就用缓冲队列把数据缓冲下来，一个一个慢慢的处理，但缓冲队列也有限度，超出这个限度，缓冲队列容纳不下，包就会被丢掉。\n\n## 传输层\n\n传输层是只有计算机才有的层次，主要提供是进程间`逻辑通信` + `可靠传输`或者`不可靠`的功能。比如 QQ 视频聊天，这就是不同计算机之间，进程间的通信。\n\n这里简单说一下`可靠传输协议TCP` + `不可靠传输协议UDP`\n\n> TCP 面向连接，可靠，不提供广播和多播，而且时间延迟比较大，适用于大文件传输。 UDP 无连接，收到的报也不确认，但时间延迟小，适用于小文件。\n\n### 端口号有什么用\n\n端口号可以用来标识同一个主机上通信的不同应用程序（就是哪个应用程序在使用这个端口）。\n\n那为什么一个端口只能分配给一个应用程序，不能是多个呢？\n\n如果服务器有两个应用程序 A，B，分别启动了 A 服务和 B 服务，它们监听同一个端口，那有数据来的时候，服务器无法判断这个数据到底是给 A，还是给 B。\n\n### 用户数据报协议 UDP\n\nUDP 协议是参考模型中一种`无连接`的传输层协议，提供面向事务的简单不可靠信息传送服务。\n\n#### UDP 协议的特点\n\n- UDP 是`无连接`的，减少开销和发送数据之前的时间延迟。`TCP`的`三次握手和四次挥手`，这个是需要时间花销的，但是 UDP 没有这部分花销。\n- UDP 使用最`大努力交付`，即不保证可靠交付。那谁来保证可靠的交付呢？是由 UDP 的上一层协议，应用层来保证。\n- UDP 是`面向报文`的，适合一次性传输少量数据的网络应用。什么意思呢，如下图，UDP 这层，把应用层的全部内容作为自己的数据报部分，在 IP 层也只是加了一个 IP 首部，我们知道，在以太网，链路层上的数据如果超过 1500 字节，就会分片，所以网络层发现上面传输层给了太大的数据就会分片，加上 UDP 是不可靠的协议，这就加大了 UDP 的不可靠性，容易丢失，所以 UDP 适合数据量少的。\n\n![Alt text](/img/notes/2020-3-27_1_19.png)\n\n- UDP `没有拥塞控制`，适合很多实时应用。也就是说如果网络堵塞，UDP 不管那么多，照样按照自己的速率发数据，那有些人就会说，这协议是不是有点坑 B，路都堵上了，还发死劲发数据呢，但是反过来看，这也是 UDP 的优点，它允许丢包，如果你的网络情况还不错，UDP 就非常适合实时应用，比如视频会议。\n- UDP 支持一对一、一对多、多对一和多对多的交互通信。\n- UDP `首部较小`，只有 8 字节，而 TCP 由 20 字节。这也是减少网络传输开销的一方面。\n\n#### DUP 首部\n\n![Alt text](/img/notes/2020-3-27_1_20.png)\n\n- 16 位端口号占了 2B，也就是 16 位，说明端口号的范围是`0 - 65535`。源端口号可以没有，因为不希望收到对方的回应，可以写全 0，目的端口是一定要有的。\n- 16 位 UDP 长度是指`首部+数据的长度`，比如数据 2B，首部固定是 8B，那么 UDP 长度就是 2+8 = 10B\n- 16 位 UDP 校验和，是用来校验`首部和数据有错误`，如果有错就丢弃掉。比如说目的主机找不到对应的端口号，就会给发送方返回一个 ICMP，`端口不可达`的差错报文。\n\n### 传输控制协议 TCP\n\nTCP 协议简单来说是一种位于传输层的，面向连接的、可靠的、基于字节流的传输层通信协议。\n\n#### TCP 协议的特点\n\n- TCP 是`面向连接`的传输层协议。比如说 TCP 的三次握手，四次分手，针对的都是连接。\n- 每一条 TCP 连接`只能有两个端点`，每一条 TCP 连接是点对点的。也就是说 TCP 是不同计算机之间的进程的通信。\n- TCP 提供`可靠交付`的服务，无差错，不丢失，不重复，按序到达。总结一下就是，`可靠有序，不丢不重`。\n- TCP 提供`全双工通信`。全双工指的是连接双方可以同时收发数据。在收发两端都有发送缓存和接收缓存，发送缓存就是一个准备发送的队列，接收缓存是一个准备接收的队列。\n- TCP `面向字节流`。如下图。\n\n![Alt text](/img/notes/2020-3-27_1_21.png)\n\n图中的 1，2，3，4.....数据块，每一个表示一个字节。TCP 将应用层的数据变为了这样的字节进行发送，比如 node 中的 buffer 就是字节流。\n\n#### TCP 首部\n\n如下图所示，我们看一下比较重要的一些首部字段，这里我们介绍`固定的20字节`的 TCP 首部。\n\n![Alt text](/img/notes/2020-3-27_1_22.png)\n\n- 源端口和目的端口分别是指发送方应用程序的端口和目的方应用程序的端口号。\n- 序号是指在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，本字段表示`本报文段所发送数据的第一个字节的序号`。\n- 确认号是指`期望收到对方下一个报文段的第一个数据字节的序号` 。若确认号为 N，则证明到需要 N-1 为止所有的数据都已经正确收到。\n- 数据偏移指的是 TCP 报文段的数据起始距离 TCP 报文段的起始处有多远。\n\n- 6 个控制位介绍：\n  | 控制位 | 作用                                                                              |\n  | ------ | --------------------------------------------------------------------------------- |\n  | ACK    | 置 1 时表示确认号合法，为 0 的时候表示数据段不包含确认信息，确认号被忽略          |\n  | PSH    | 置 1 时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送 |\n  | RST    | 置 1 时重建连接。如果接收到 RST 位时候，通常发生了某些错                          |\n  | SYN    | 置 1 时用来发起一个连接                                                           |\n  | FIN    | 置 1 时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了           |\n  | URG    | 紧急指针，告诉接收 TCP 模块紧要指针域指着紧要数据                                 |\n\n#### TCP 建立连接\n\n如下图所示：\n\n![Alt text](/img/notes/2020-3-27_1_23.png)\n\n1. 首先客户端要发送一个数据报告诉服务器要建立连接，根据上面了解到的控制位信息，建立连接需要把`SYN置为1`，同时选择一个初始序号`seq`，是随机产生的。TCP 规定，`SYN=1`的报文段不能携带数据，但要消耗一个序号。\n2. 然后服务器收到该数据报后，会为该 TCP 连接分配缓存和变量，缓存指的是一个字节流队列。（发送方和接收方都有这个队列，而且如果双方需要互相通信，那么双方都会有发送缓存和接收缓存），接着会返回一个确认报文，其中 `SYN 控制位置为 1`，意思是允许建立连接，`ACK 也置为1`，确认收到了发送方的报，并且会设一个 seq ，也为一个随机数。小写 ack 是确认号，也就是接下来希望发送方要发的数据从哪开始, `ack=x+1`。\n3. 最后，客户端需要给服务器端返回一个确认，此时 SYN 控制位变为 0，意思这不是建立连接的请求了，要正式发数据了，ACK 是确认码，意思是收到了服务器的确认请求了。\n\n若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据报。\n\n#### TCP 释放连接\n\n如下图所示：\n\n![Alt text](/img/notes/2020-3-27_1_24.png)\n\n- 客户端发起请求，请求断开链接。`FIN=1，seq=u`。u 是之前传送过的数据的最后一个字节的序号+1。FIN：用来释放一个链接，当`FIN=1`的时候，表明此报文的发送方已经完成了数据的发送，没有新的数据要传送，并要求释放链接。客户端等着服务器返回确认。FIN 报文段即使不携带数据，也消耗掉一个序号。\n- 服务器收到客户端的请求断开链接的报文之后，返回确认信息。`ACK=1，seq=v，ack=u+1`。这个时候，客户端不能给服务器发送信息报文，只能接收。但是服务器要是还有信息要传给服务器，仍然能传送。\n- 当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。`FIN=1，ACK=1，ack=u+1，seq=w`。这里的 w，跟上面的 v 是一个意思，为什么不都是 v 呢，因为这一步和上一步中间可能还在发数据呢，所以 seq 这个数据发送的字节流序号可能要变。\n- 客户端接收到`FIN=1`的报文之后，返回确认报文，`ACK=1，seq=u+1，ack=w+1`。发送完毕之后，客户端进入等待状态，等待两个时间周期。关闭。\n\n为什么最后还要等待两个时间周期呢？\n\n![Alt text](/img/notes/2020-3-27_1_25.png)\n\n#### 相关问题\n\n1、三次是最小的安全次数，可以保证通信的双方都具有发送消息和接收响应的能力，发送方和接收方始终同步序号，可以实现可靠传输。\n\n![Alt text](/img/notes/2020-3-27_1_26.png)\n\n2、如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\n`TCP保活计时器` 每次客户端请求服务器会重置计时器，当`2小时之内`没收到客户端任何数据时，会每隔`75s`向客户端发一个探测报文，若接连发送`10`个，客户端都没有反应，则认为客户端故障，关闭连接。\n\n3、什么是 SYN 洪泛攻击？\n\nSYN 洪泛攻击就是利用 TCP 协议的特性（三次握手）。攻击者发送 TCP 的 SYN，SYN 是 TCP 三次握手中第一个数据报，而当服务器返回 ACK 后，该攻击者就不对其进行再确认，那这个 TCP 连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复发送 ACK 给攻击者。这样更加会浪费服务器资源。攻击者就对服务器发送大量的这种 TCP 连接，由于每一个连接都无法完成三次握手，所以就在服务器上，这些 TCP 连接会因为挂起状态而消耗 CPU 和内存，最后服务器可能死机。\n\n4、序号为什么要随机？\n\n增加安全性，为了避免被第三方猜测到，从而被第三方伪造的 RST 报文 Reset。\n\n5、三次握手的第一次可以携带数据吗？为何？\n\n不可以，三次握手还没有完成。而且这样会放大`SYN FLOOD`（SYN 洪泛）攻击。\n如果攻击者伪造了成千上万的握手报文，携带了 1K+ 字节的数据，而接收方会开辟大量的缓存来容纳这些巨大数据，内存会很容易耗尽，从而拒绝服务。\n\n6、三次握手的第三次可以携带数据吗？为何？\n\n第三次握手，此时客户端已经处于`ESTABLISHED`状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。\n\n#### TCP 如何实现可靠传输\n\n主要通过以下四种方式实现可靠传输机制：\n\n- 校验。伪首部是为了增加 TCP 校验和的检错能力：通过伪首部的目的 IP 地址来检查 TCP 报文是否收错了、通过伪首部的传输层协议号来检查传输层协议是否选对了。需要注意的是，伪首部实际上是不存在的，只是用来验证 TCP 报文是否出错。\n- 序号。之前我们提到 TCP 是面向字节流的，比如第一个字节就是序号 1，第二个字节就是序号 2。 而在 TCP 报文格式介绍的时候，有一个序号字段，这个指的是一个报文段第一个字节的序号。报文段就是你每个数据包。有了序号，就能保证数据是有序的传入应用层。\n- 确认。发送方在收到接收方的确认报 之后，才继续发送剩下的数据。\n- 重传。TCP 的发送方在规定的时间内没有收到确认就要重传已发送的报文段（超时重传）。重传时间是动态改变的，依据的是 RTTS（加权平均往返时间）。\n\n#### TCP 的流量控制\n\n比如发送方发送速度非常快，接收方接收速度特别慢，这样就会发生严重的丢包现象。\n\nTCP 通过滑动窗口的机制来实现流量控制。简单来说如下：\n\n- TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。\n- 当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。\n\n#### TCP 的拥塞控制\n\n- 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。\n- TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。\n- 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。\n\n为了便于讨论，做如下假设：\n\n- 接收方有足够大的接收缓存，因此不会发生流量控制；\n- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。\n\n慢开始与拥塞避免：\n\n- 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...\n- 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。\n\n如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。\n\n快重传与快恢复：\n\n- 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。\n- 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。\n- 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。\n- 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。\n\n## 应用层\n\n### 应用层作用\n\n应用层对应用程序的通信提供服务。\n\n- 区分是发送报文还是接收报文\n- 定义报文类型的语法，比如某字段的意思，例如 http 中 content-type 字段是什么意思。\n- 最后就是进程如何，什么时候把传输层的数据交给应用层。\n\n一些比较重要的应用层协议如下图：\n\n![Alt text](/img/notes/2020-3-27_1_27.png)\n\n### 应用层常见的模型\n\n第一种是客户端/服务器模型，也就是 C/S 架构。比如电子邮件、web 都是。\n\n![Alt text](/img/notes/2020-3-27_1_28.png)\n\n第二种是 P2P 模型，每个主机既可以提供服务，也可以请求服务。比如迅雷下载也是使用 P2P 技术的。\n\n![Alt text](/img/notes/2020-3-27_1_29.png)\n\n### 短链接和长链接\n\nTCP 连接有两种工作方式：短连接方式（Short-Live Connection）和长连接方式（Long-Live Connection）。\n\n短连接方式：\n\n当客户端有请求时，会建立一个 TCP 连接，接收到服务器响应后，就断开连接。下次有请求时，再建立连接，收到响应后，再断开。如此循环。这种方式主要有两个缺点：\n\n- 建立 TCP 连接需要 3 次“握手”，拆除 TCP 连接需要 4 次“挥手”，这就需要 7 个数据报。如果请求和响应各占 1 个数据报，那么一次短连接的交互过程，有效的传输仅占 2/9，这个利用率太低了。\n- 主动断开 TCP 连接的一端，TCP 状态机会进入`TIME_WAIT`状态。如果频繁地使用短连接方式，就有可能使客户端的机器产生大量的处于`TIME_WAIT`状态 TCP 连接。\n\n长连接方式：\n客户端和服务器建立 TCP 连接后，会一直使用这条连接进行数据交互，直到没有数据传输或异常断开。在空闲期间，通常会使用`Keep-Alive`保持链路不断开。目前长连接方式应用范围比较广泛。\n\n#### 持久连接\n\n`Keep-Alive`是`http/1.1`增加的。 在没有`Keep-Alive`之前，HTTP 请求都是短连接，就是说每一次请求都要建立连接，请求完成后马上关闭连接，也就是我们上面说的三次握手和四次挥手过程，每次请求都要建立连接带来了资源的浪费，为了提高请求效率，于是有了`Keep-Alive`。\n\n`Keep—Alive`允许在一定时间内，同一个域名多次请求数据，只建立一次 HTTP 连接，其他请求可以复用这个连接通道，以达到提高请求效率的目的。\n\n持久连接使得多数请求以`管状化`方式成为可能。以前发送请求后需要等待并收到响应，才能发送下一个请求。管状化技术出现后，不用等待响应也可直接发送下一个请求。\n\n### DNS\n\nDNS 就是将域名转化为 IP，比如 `www.qq.com`，这是域名，可以是网络报需要对方 IP 地址，域名是不能加入网络报报头的，所以就需要去找一个服务器问，qq 的域名对应的 IP 是多少。\n\n大概的通信过程如下：\n\n1. 用户主机上运行着`DNS`的客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端了\n2. 浏览器将接收到的 url 中抽取出域名字段，就是访问的主机名，比如 `http://www.baidu.com/` , 并将这个主机名传送给 DNS 应用的客户端\n3. DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式 DNS 集群的工作）\n4. 该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址\n5. 一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接\n\n### 万维网和 HTTP 协议\n\n万维网 www 是一个大规模的、联机式的信息存储所，是无数个网络站点和网页的集合。`互联网包含因特网，因特网包含万维网`。\n\n- `互联网internet`。凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分，国际标准的互联网写法是 internet，字母 i 一定要小写！\n- `因特网Internet`。而因特网是互联网中的一种，它可不是仅有两台机器组成的网络，而是由上千万台设备组成的网络（该网络具备很大的规模）。因特网使用 TCP/IP 协议让不同的设备可以彼此通信。但使用 TCP/IP 协议的网络并不一定是因特网，一个局域网也可以使用 TCP/IP 协议。\n- 因特网是基于 TCP/IP 协议实现的，TCP/IP 协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如 FTP、SMTP、HTTP。所以，因特网提供的服务一般包括有：www（万维网）服务、电子邮件服务（outlook）、远程登录（QQ）服务、文件传输（FTP）服务、网络电话等等。\n- `万维网`。只要应用层使用的是 HTTP 协议，就称为万维网(World Wide Web)。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是 HTTP 协议在交流。\n\n万维网使用统一资源定位符 URL 作为标识符来访问资源。\n\nURL 的格式如下：\n\n![Alt text](/img/notes/2020-3-27_1_30.png)\n\n用户通过点击超链接获取资源，这些资源通过超文本传输协议（HTTP）传送给使用者。\n\nHTTP 协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。\n\n![Alt text](/img/notes/2020-3-27_1_31.png)\n\n### HTTP 常用状态码\n\n- `200 OK`表示从客户端发来的请求被正常处理了。\n- `204 No Content`表示服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回实体的主体。比如`OPTIONS`请求。\n- `206 Partial Content`表示客户端进行了范围请求，而服务器成功执行了这部分请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n- `301 Moved Permanently`永久重定向。表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。\n- `302 Found`临时性重定向。表示请求的资源已被分配了新的 URI，希望用户本次能使用新的 URI 访问。\n- `303 See Other`表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。`303`和`302`有着相同的功能，但`303`明确表示客户端应该用`GET`的方法获取资源。\n- `304 Not Modified`表示客户端发送附带条件（GET 方法的请求报文中包含 If-Match, If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since 中的任一首部）的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回`304`。`304`返回时，不包含任何响应的主体部分。\n- `307 Temporary Redirect`临时重定向。`307`会遵照浏览器标准，不会从`POST`变成`GET`。\n- `400 Bad Request`表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。浏览器会像`200`一样对待该状态码。\n- `401 Unauthorized`表示发送的请求需要有通过 HTTP 认证的认证信息。\n- `403 Forbidden`表示对请求资源的访问被服务器拒绝了。\n- `404 Not Found`表明服务器上无法找到请求的资源。\n- `500 Internal Server Error`表明服务器端在执行请求时发生了错误。\n- `503 Service Unavailable`表明服务器暂时处于超负载或在进行停机维护，现在无法处理请求。\n\n### HTTP 缺点\n\n- 通信使用明文（不加密），内容可能会被窃听\n- 不会验证通信方的身份，因此可能会遭遇伪装\n- 无法保证报文的完整性，请求或响应的内容被篡改也无法知道\n\n### HTTPS\n\nHTTPS = HTTP + 加密 + 身份验证 + 数据完整性保护\n\nHTTPS 和 HTTP 区别：\n\n- HTTP 使用明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议\n- HTTP 不会验证通信方的身份，HTTPS 会通过数字证书来验证身份\n- HTTPS 可以保证数据的完整性，防止传输内容被中间人冒充或篡改\n- 除以上外，HTTP 和 HTTPS 使用的端口也不同，前者使用 80 端口，后者使用 443 端口\n\n### HTTP/2.0\n\n相关概念：\n\n- 帧： HTTP/2 数据通信的最小单位。每个帧都包含帧首部，其中会标识当前帧所属的流。\n- 消息： 指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。 、\n- 流： 存在于连接中的虚拟通道。流可以承接双向消息，每个流都有一个唯一的整数 id。\n- 连接： 与 HTTP/1 相同，都是指对应的 TCP 连接。\n\nHTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。而 HTTP/2 将请求和响应数据分隔成为更小的帧，并对他们采用二进制编码。\n\n相比 HTTP/1 的优化：\n\n- 提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 HTTP/1）\n- 允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 HTTP/1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。\n- 二进制分帧：HTTP/2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码\n- 首部压缩\n- 服务器端推送\n\nHTTP/2 中，同域名下的所有请求都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，消息由一个或多个帧组成。多个帧之间可以乱序发送，然后根据帧首部的流标识可以重新组装。\n\n### WebSocket 协议\n\n主要特点：\n\n- 推送功能\n- 减少通信量\n\n握手-请求\n\n```plain\nUpgrade: websocket\nConnection: Upgrade\n```\n\n握手-响应\n\n```plain\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\n```\n\n### 在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？\n\n1. 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 HTTP 协议就按照 Web 方式来处理。\n\n2. 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法。\n\n3. 然后去找到这个 URL 对应的 IP 地址,为了寻找这个 IP 地址，浏览器首先会查找：浏览器缓存 -> 操作系统缓存 -> 本地 host 文件 -> 路由器缓存 -> DNS 服务器。\n\n    `DNS 负载均衡`： 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用 DNS 负载均衡技术，它的原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址,在应答 DNS 查询时,DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。\n\n4. 拿到域名对应的 IP 地址之后，浏览器根据这个 IP 地址以及相应的端口号会向服务器发起 TCP 的连接请求。\n\n5. 发送 HTTP 请求。\n\n6. 服务器处理请求。\n\n    一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过 HTTP 协议访问某网站应用服务器，而是先请求到 Nginx，Nginx 再请求应用服务器，然后将结果返回给客户端，这里 Nginx 的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。\n\n7. 服务器返回一个 HTTP 响应。\n\n    > 使用[缓存](/2021/05/14/RESTful-API/)\n\n8. 浏览器解析渲染页面。\n\n    浏览器是一个边解析边渲染的过程。首先浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和 repain(重绘)。DOM 节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为 repain。页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。\n\n    > [重绘 repain 和重排(回流)reflow 以及优化方法](<./性能相关.md#重绘repain和重排(回流)reflow以及优化方法>)\n\n    当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。因为 JS 有可能会修改 DOM，最为经典的 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的根本原因。所以我明平时的代码中，js 是放在 html 文档末尾的。\n\n    JS 的解析是由浏览器中的 JS 解析引擎完成的。JS 是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。\n\n    JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。\n\n9. 连接结束\n    ​\n    现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭。\n","source":"_posts/计算机网络.md","raw":"---\ntitle: 计算机网络\ndate: 2020-03-27 18:44:43\ntags: ['计算机基础']\n---\n\n## 概述\n\n计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。\n\n按分布范围，计算机网络里有`局域网LAN`和`广域网WAN`, 其中局域网的代表以太网，以及这两种网络最重要的区分点，局域网基于`广播技术`，广域网基于`分组交换`技术。\n\n### 网络的网络\n\n网络把主机连接起来，而互连网`internet`是把多种不同的网络连接起来，因此互连网是网络的网络。而英特网`Internet`是全球范围的互连网。\n\n### ISP\n\n{% note primary %}\nISP (Internet service provider) 互联网服务提供商\n{% endnote %}\n\n`ISP`可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向`ISP`缴纳一定的费用就可以接入互联网。\n\n目前的互联网是一种多层次`ISP`结构，`ISP`根据覆盖面积的大小分为第一层`ISP`、区域`ISP`和接入`ISP`。互联网交换点 IXP 允许两个`ISP`直接相连而不用经过第三个`ISP`。\n\n### 主机之间的通信方式\n\n- 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。\n- 对等（P2P）：不区分客户和服务器。\n\n### 电路交换与分组交换\n\n- 电路交换\n\n  电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。\n\n- 分组交换\n\n  每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。\n\n在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。\n\n### 衡量计算机网络的性能的指标\n\n#### 速率\n\n速率就是数据传输（数据是指 0 和 1）的速率，比如用迅雷下载，1 兆每秒，来衡量目前数据传输的快慢。它是计算机网络中最重要的一个性能指标。\n\n#### 带宽\n\n在计算机网络中，网络带宽是指在单位时间（一般指的是 1 秒钟）内能传输的数据量，比如说你家的电信网络是 100 兆比特，意思是，一秒内最大的传输速率是 100 兆比特。\n\n#### 吞吐量\n\n吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。\n\n{% note primary %}\n由此可知带宽说的是最大值速率，吞吐量说的是某时刻速率。但吞吐量不能超过最大速率\n{% endnote %}\n\n#### 时延\n\n时延是指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。单位是 s。 时延分以下几种：\n\n- 排队时延：分组在经过网络传输时，要经过很多的`路由器`。但分组在进入路由器后要先在输入队列中`排队等待`处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发，这就产生了`排队时延`。排队时延的长短往往却决于网络当时的通信量，当网络的通信量很大时会发生排队溢出，是`分组丢失`。\n- 处理时延：`路由器`或`主机`在收到数据报时，要花费一定时间进行处理，例如`分析数据报的首部`、进行`首部差错检验`，`查找路由表`为数据报选定准发接口，这就产生了处理时延。\n- 发送时延：主机或路由器传输数据帧所需要的时间。\n- 传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。\n\n{% note primary %}\n总时延 = 排队时延 + 处理时延 + 发送时延 + 传播时延\n{% endnote %}\n\n#### 往返时间（RTT）\n\n在计算机网络中，往返时间也是一个重要的性能指标，它表示从发送方发送数据开始，到发送方收到来自接收方的确认（接受方收到数据后便立即发送确认）总共经历的时间。\n\n#### 时延带宽积\n\n是指传播时延乘以带宽。\n\n### 计算机网络体系结构\n\n![计算机网络体系结构](/img/notes/2020-3-27_1_32.png)\n\n#### 五层协议\n\n- 应用层：为特定应用程序提供数据传输服务，例如`HTTP`、`DNS`等协议。数据单位为报文。\n- 传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议`TCP`，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 `UDP`，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。`TCP`主要提供完整性服务，`UDP`主要提供及时性服务。\n- 网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。\n- 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。\n- 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n\n#### OSI\n\n{% note primary %}\nOSI (Open System Interconnection Model)\n{% endnote %}\n\n如下图所示，1、2、3 层主要是`物理链路`组成的，比如`光纤`，`路由器`，`集线器`，主要负责的是`数据通信`。5、6、7 层是`软件控制`的，比如`HTTP`协议，是一种软件层面控制的协议，主要负责处理传输来的`数据`。\n\n![OSI](/img/notes/2020-3-27_1_1.png)\n\n其中表示层和会话层用途如下:\n\n- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。\n\n- 会话层：建立及管理会话。\n\n五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。\n\n#### TCP/IP\n\n它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。\n\n`TCP/IP`体系结构不严格遵循`OSI`分层概念，应用层可能会直接使用IP层或者网络接口层。\n\n#### 数据在各层之间的传递过程\n\n在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。\n\n路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。\n\n## 物理层\n\n### 物理层作用\n\n对于物理层，有人会说，这不就是网线吗，比如家里连接路由器的网线，电线杆上的光纤？其实不然，物理层更多的是规定一种标准，他并不管物理介质具体是什么，比如电线杆上是光纤还是双绞线，只要你能按物理层规定的标准传输数据就行。\n\n{% note primary %}\n物理层是规定传输媒体接口的标准\n{% endnote %}\n\n### 通信方式\n\n根据信息在传输线上的传送方向，分为以下三种通信方式：\n\n- 单工通信：单向传输。\n- 半双工通信：双向交替传输。是指允许数据在两个方向上传输，但是在某一时刻只允许数据在一个方向上传输。\n- 全双工通信：双向同时传输。\n\n### 光纤宽带上网的传输数据形式\n\n- 首先计算机网卡传输出来的数据是`电信号`，光纤传输的是`光脉冲`信号，有光脉冲表示`1`，无光脉冲表示`0`。\n- 而可见光的频率大约是`10的8次方MHz`，因此光纤通信系统的带宽远远大于其它各种传输媒体的带宽\n- 所以我们计算机传输数据需要先把`电信号`转为`光信号`，然后`光信号`快到服务器的时候，再把`光信号`转为`电信号`。\n\n### 物理层设备中继器\n\n为什么需要中继器呢？因为再线路上传输的信号功率会`逐渐衰减`，衰减到一定程度时将造成`信号失真`，因此会导致接收错误。中继器可以对信号进行`再生`和`还原`，增加信号的传输距离。\n\n需要注意的是，中继器两端连接不同的网段，而不是子网。\n\n## 数据链路层\n\n### 主要功能\n\n- 封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。封装的网络数据报，在链路层就叫`数据帧`。\n- 透明传输：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。\n- 差错控制：在文件送到 B 公司小秘书手里的时候，快递包上写着 5 个文件，秘书一看只有 3 个文件，就会让物理层重新发送有没有送到的文件。目前数据链路层广泛使用了`CRC循环冗余检验`来检查比特差错。\n- 差错纠正：链路层知道 1，2，3，4，5 个文件，丢失的两个文件到底是哪两个，并且能通过重新发送没有的文件来纠正。\n- 流量控制：比如说发送方发送速度特别快，接收方接收速度特别慢，会造成传输出错。\n\n这里需要注意的是，传输层 TCP 也有流量控制功能，区别在于 TCP 是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）流量控制的方法有滑动窗口协议，以及选择重传协议。\n\n### 通信分类\n\n#### 广播信道\n\n一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。\n\n所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。\n\n主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。\n\n#### 点对点信道\n\n一对一通信。\n\n因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。\n\n### CSMA/CD 协议\n\n`CSMA/CD`表示载波监听多点接入/碰撞检测。\n\n- 多点接入：说明这是总线型网络（半双工），许多主机以多点的方式连接到总线上。\n- 载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。\n- 碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。\n\n### PPP 协议\n\n互联网用户通常需要连接到某个`ISP`之后才能接入到互联网，`PPP`协议是用户计算机和`ISP`进行通信时所使用的数据链路层协议。\n\nPPP 的帧格式：\n\n- F 字段为帧的定界符\n- A 和 C 字段暂时没有意义\n- FCS 字段是使用 CRC 的检验序列\n- 信息部分的长度不超过 1500\n\n### MAC地址\n\n`MAC地址`是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。\n\n一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。\n\n### 局域网\n\n局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。\n\n主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。\n\n可以按照网络拓扑结构对局域网进行分类：\n\n![局域网拓扑结构](/img/notes/2020-3-27_1_33.png)\n\n### 以太网\n\n以太网是一种`局域网`技术，其规定了`访问控制方法`、`传输控制协议`、`网络拓扑结构`、`传输速率`等，完成数据链路层和物理层的一些内容，它采用一种称作`CSMA/CD`的媒体接入方法，另外的一些局域网技术，比如无线局域网等。\n\n#### 以太网的帧格式\n\n![以太网的帧格式](/img/notes/2020-3-27_1_2.png)\n\n- 其中`目的地址`和`源地址`指的是`MAC地址`，即设备的物理地址。`MAC地址`用于标示网卡，每个网卡都具有唯一的`MAC地址`。\n- 当在同一个局域网中，主机`A`需要给主机`B`发送消息时，主机`A`将以太网帧发出，此时局域网中所有主机均可收到这个桢，主机中的网卡接收到以太网桢后，会将目的`MAC地址`和自己的`MAC地址`进行比较,如果不相同就会丢弃，如果相同则会接收，此时则`Ｂ`主机就收到了`Ａ`的消息。\n- 其最后面是`CRC循环冗余码`，用于差错控制，即检验帧的正确性。\n- 在以太网协议中，目的地址分为三种`单播地址`、`广播地址`、`多播地址`，其中`单播地址`如上面`Ａ`给`Ｂ`主机发送，其接收者为一个，并且其目的地址的最高字节的低位为`0`。\n\n#### 以太网的特点\n\n- 无连接。发送方和接收方不建立连接。\n- 不可靠。接收方不向发送方进行确认，差错帧直接丢弃。\n\n#### 以太网的拓扑结构\n\n跟以太网相关的拓扑结构有`星型`和`总线型`。\n\n互联网初期，以太网的`总线型拓扑`比较普遍。随着总线型以太网上的站点数目增多,`可靠性也会随之下降`,而随着大规模集成电路以及专门芯片的发展,使得`星型以太网变得便宜又可靠`。\n\n需要注意的是，以太网虽然物理上是`星型拓扑`，但逻辑上是`总线型`。\n\n### 网卡\n\n计算机传出的数据，经过网卡，就会变为`以太网的帧`，还会完成一些`链路管理`（CSMA/CD 的实现），以及`编码`和`译码`。\n\n### 无线局域网\n\n无线局域网 WLAN 是利用无线电波、激光和红外线等无线通信技术来构建的局域网。\n\n### 链路层的设备\n\n#### 网桥\n\n网桥根据`MAC帧`的目的地址进行转发和过滤。当网桥收到一个帧时，并不会向所有接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个口，或者是把它丢弃。\n\n这里需要注意的是，网桥连接的是不同的网段.\n\n#### 交换机\n\n谈到交换机，就不得不提两个概念，`冲突域`和`广播域`\n\n- 冲突域： 是指同一时间只能由一台设备发送信息的范围。\n- 广播域：如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为广播域\n\n也就是说，广播域可以跨网段，而冲突域只是发生的同一个网段。\n\n举个例子，公司里大家的电脑一般都是连接到交换机上，因为交换机可以隔离冲突域，冲突域的最大问题在于，同一时间只能有一台机器传输数据，公司那么多人，如果这样的话，传输数据速度太慢了。然后交换机再连接到路由器上，首先路由器能隔离广播域，其次不经过路由器，你的数据链路层上的包没办法进入到互联网里面去，路由器是网络层的设备。\n\n交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。\n\n正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。\n\n下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。\n\n![交换机交换表](/img/notes/2020-3-27_1_3.png)\n\n## 网络层\n\n网络层主要任务是将`分组`从一台主机移动到另一台主机，从而提供了`主机到主机的通信服务`和各种形式的`进程到进程的通信`。\n\n分组：大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发动，这种小块就称作分组。\n\n### 分组交换\n\n当`主机H1`要向另一`主机H2`发送数据（报文）时，首先将数据划分成若干个等长的分组，然后将这些分组一个接一个地发往里与`H1`相联的`路由A`,当`A`接到分组后，先放入缓冲区，再按一定的路由算法确定该分组下一步将发注哪个结点，如此一个结点一个结点传递，直到最终目的`H2`。\n\n这一段话比较啰嗦，简单来说分组就是`分数据块`，同时还具有`无需建立连接`，存储转发（存储转发是指以太网交换机的控制器先将输入端口到来的数据报缓存起来，先检查数据报是否正确，并过滤掉冲突包错误），`动态分配路线`（交换设备会根据网络状况选择不同的路线，比如路由器）的优点。\n\n### 数据报\n\n数据报是通过网络传输的`数据的基本单元`，包含一个`报头（header）`和`数据`本身。说白了，就是带地址的数据，比如你的写了一句微信\"你好\"，这串文字本上加上源地址，目的地址，就是数据报。\n\n### IP 数据报格式\n\n![IP数据报格式](/img/notes/2020-3-27_1_5.png)\n\n- 首部的**固定部分**是`20字节`，共 `20 * 8 = 160` 比特（1 字节=8 比特）。\n- **版本**：占4位，有 4（IPv4）和 6（IPv6）两个值。\n- **首部长度**：`单位是 4B`，最小为 5，因为首部至少 20 字节，所以 4 \\* 5 就是 20 字节。\n- **区分服务** ：用来获得更好的服务，一般情况下不使用。\n- **总长度**：首部长度+数据部分长度。\n- **标识**： 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。\n- **片偏移** ：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。\n- **生存时间**：`TTL`，它告诉网络，数据报在网络中的时间是否太长而应被丢弃。以路由器跳数为单位，每经过一个路由器减一，变成 0 就丢弃。\n- **协议**：是指数据部分用的什么协议，我们只需要知道`TCP`协议用`6`表示，`UDP`协议用`17`表示即可。\n- **首部校验和**：这个字段只检验数据报的首部，不包括数据部分，因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。\n- **目的地址**和**源地址**都是`IP地址`，目的地址是通过`DNS`查询得来的。\n\n### IP 分片\n\n为什么需要分片：链路层数据帧封装的数据大小是有限制的，以太网的 MTU（MTU 是指一种通信协议的某一层上面所能通过的最大数据报大小）是 1500 字节。\n\n在 IP 数据报上，标识了分片的数据的字段：\n\n![IP数据报格式](/img/notes/2020-3-27_1_7.png)\n\n- **标识**\n- **标志**：占 3 位，但只有两位有意义，第一个位叫`MF(More Fragment)`，MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。中间的一位记为`DF(Don’t Fragment)`，意思是“不能分片”。只有当 DF=0 时才允许分片。\n- **片偏移**：较长的分组在分片后，某片在原分组中的相对位置。\n\n![数据报的分片举例](/img/notes/2020-3-27_1_34.png)\n\n### IP 地址分类\n\n![IP地址分类](/img/notes/2020-3-27_1_6.png)\n\n其中`127.0.0.0~127.255.255.255`用于环回测试。\n\n有一部分叫`私有IP地址`，是不能拿到网络上跟别的计算机通信的。只能是局域网自己内部用。比如说有：\n\n![私有IP地址](/img/notes/2020-3-27_1_8.png)\n\n可以看到，C 类私有地址就是`192.168`网段，每个局域网都可以有这些私有 IP。\n\n还有一些`特殊地址`，需要了解：\n\n![特殊地址](/img/notes/2020-3-27_1_9.png)\n\n注意，这里的全 1 是指，IPV4 地址由 4 个字节组成，每一个字节是 8 位，8 位全一就是十进制的 255, 即`255.255.255.255`。\n\n- 第一行，全一，代表是`255.255.255.255`，在本网络的目的地址写这个的话，就会内网广播。\n- 第二行，网络号特定值，主机号是全 0，比如，`192.169.10.1`，这是 c 类网络，所以网络号是`192.169.10`，主机号是 1，当主机号全 0 时，就是 0，表示`192.169.10.0`这个网段。\n- 第三行，还是`192.169.10.1`这个 c 类地址，主机号都是 1，也就是 8 个 1，代表 255，所以 `192.169.10.255`表示本网段的广播地址。\n- 第四行，127 作为网络号，主机号非全 0 或 1，比如说`127.0.0.1`代表本机，称为环回地址。\n\nIPV4 中，`0.0.0.0`地址被用于表示一个无效的，未知的或者不可用的目标。在服务器中，`0.0.0.0`指的是本机上的所有 IPV4 地址，如果一个主机有两个 IP 地址，`192.168.1.1`和`10.1.2.1`，并且该主机上的一个服务监听的地址是`0.0.0.0`，那么通过两个 IP 地址都能够访问该服务。\n\n### 网络地址转换(NAT)\n\n在 IP 地址分类里面，我们知道私有 IP 地址是不能跟外网交互的，在小公司大多数计算机的地址都是`192.168`网段，都是私有 IP 地址，它是怎么跟外网交互数据的呢，这里就引出来一个知识点叫`网络地址转换NAT`。\n\n![网络地址转换NAT](/img/notes/2020-3-27_1_10.png)\n\n如上图所示，`192.168.0.3`，`192.168.0.4`都是私有网段上的，它们无法跟外网通信，这个时候由于路由器安装了 NAT 软件，就可以将自己的 IP 地址，即路由器的 IP 地址`172.38.1.5`作为内网的代理，去访问外网，外网返回来的数据，经过路由转换，转换成内网的`192.168`网段的私有地址。\n\n### 子网划分和子网掩码\n\n划分子网的方式是从网络的主机号借用若干位作为子网号，主机号也就相应减少了同样的位数。\n\n![子网划分](/img/notes/2020-3-27_1_11.png)\n\n当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。\n\n我们将`145.13.0.0`这个网段划分了三个子网，其中一个是`145.13.3.0`，一个是`145.13.21.0`，问题来了，如果一个数据报来了，数据报要交给的 IP 地址是`145.13.3.10`，我们怎么知道给哪个子网呢？\n\n方法是将数据报的目的地址，跟子网的子网掩码相与预算（二进制与预算规则是，1 跟 1 得 1，其它为 0），也就是目的地址`145.13.3.10`跟子网`145.13.3.0`的子网掩码`255.255.255.0`的与预算，得到的结果是`145.13.3.0`，所以发送到的子网就是`145.13.3.0`。\n\n### 地址解析协议ARP\n\n以太网的帧的格式：\n\n![以太网的帧格式](/img/notes/2020-3-27_1_2.png)\n\n上图有一个`源地址`和`目的地址`，这两个地址都是指的`MAC地址`，`MAC地址`是什么呢？简单说来就是两台相邻的路由器 A 和 B，A 怎么把数据传给 B 呢，它总要知道 B 的物理地址吧，物理地址就像门牌号一样，我要知道你住在哪里，才能把数据送过去吧？首先你肯定知道自己的`MAC地址`是多少，因为在网卡上有，问题在于，别人的`MAC地址`是多少？`ARP协议`就是来帮你找`MAC地址`的。\n\n#### ARP协议的过程\n\n![ARP协议的过程](/img/notes/2020-3-27_1_12.png)\n\n1. 每台主机都会在自己的`ARP缓冲区`中建立一个`ARP列表`，以表示 `IP地址`和`MAC地址`的映射关系\n2. 当源主机需要将一个数据报要发送到目的主机时，会首先检查自己`ARP列表`中是否存在该`IP地址`对应的 `MAC地址`\n3. 如果有，就直接将数据报发送到这个`MAC地址`；如果没有，就向本地网段发起一个 `ARP`请求的广播报，查询此目的主机对应的`MAC地址`\n4. 此`ARP`请求数据报里包括源主机的`IP地址`、`硬件地址`、以及`目的主机的IP地址`。网络中所有的主机收到这个`ARP请求`后，会检查数据报中的目的`IP`是否和自己的`IP地址`一致\n5. 如果不相同就忽略此数据报；如果相同，该主机首先将发送端的`MAC地址`和 `IP地址`添加到自己的`ARP列表`中\n6. 如果`ARP表`中已经存在该`IP`的信息，则将其覆盖，然后给源主机发送一个 `ARP响应数据报`，告诉对方自己是它需要查找的`MAC地址`\n7. 源主机收到这个`ARP响应数据报`后，将得到的目的主机的`IP地址`和`MAC地址`添加到自己的`ARP列表`中，并利用此信息开始数据的传输\n8. 如果源主机一直没有收到`ARP响应数据报`，表示`ARP查询失败`。\n\n### DHCP 协议\n\nDHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段 lP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。当接入局域网的时候，自动由这个 DHCP 服务器分配 IP，windows 用户可能知道网卡配置里面，有自动获取 IP 的功能，如果路由器提供 DHCP 服务，就会自动获取随机分配的 IP。路由器里可以开启这个服务。\n\n大致工作过程：\n\n![DHCP数据发送过程](/img/notes/2020-3-27_1_13.png)\n\n### 网际控制报文协议ICMP\n\n一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是 IP 协议并不提供可靠传输。如果丢包了，IP 协议并不能通知传输层是否丢包以及丢包的原因。\n\n所以我们就需要一种协议来完成这样的功能–`ICMP协议`。\n\n#### ICMP 协议主要功能\n\n- 确认 IP 报是否成功到达目标地址\n- 通知在发送过程中 IP 报被丢弃的原因，举一个例子：\n\n![ICMP应答报文](/img/notes/2020-3-27_1_14.png)\n\n主机 H2 收到主机 H1 的一个`UDP报`，结果 H2 发现这个报里的端口没有被监听，这时候就回复给 H2 一个`ICMP应答报文`，意思是这个`UDP数据报`无法交给应用进程，只能丢弃了。\n\n以下是 4 种常见的 ICMP 差错报告报文：\n\n![ICMP 差错报告报文](/img/notes/2020-3-27_1_15.png)\n\n我们常用的`PING`命令借助`ICMP协议`，探测主机是否能找到目的主机。\n\n### 网络设备路由器简介\n\n路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发和分组。\n\n如下图所示，分别有转发和分组功能的说明。\n\n![路由器功能](/img/notes/2020-3-27_1_16.png)\n\n接着，我们看一下路由器输入端口做了哪些事情：\n\n![路由器输入端口](/img/notes/2020-3-27_1_17.png)\n\n- 首先，物理层是傻瓜层，传输`比特流`，我们把物理层的比特流还原成`数据链路层`的`数据帧`，然后把`数据链路层`的`数据报`脱去，成为`网络层数据报`，交给路由器。这时候就要判断一下这个数据报是什么类型的了。\n\n- 如果它是路由器之间，交换路由信息的分组，就会把这个数据报交付给如上上图所示的，路由选择处理机，进行处理和计算。如果是数据分组，就会放到一个队列里面，排队等候，然后选择一个合适的输出端口输出。\n\n最后我们看一下路由器输出端口做了哪些事情：\n\n![路由器输出端口](/img/notes/2020-3-27_1_18.png)\n\n从上图可以看到，输出端口是做的输入端口的逆过程，将网络层的数据报转换为链路层的数据帧，最后转为物理层的比特流。\n\n> 输入和输出端口需要注意的是，它们都有一个缓冲队列，比如输入数据的速度太快，输出数据速度慢，为了平衡输入输出速度，就用缓冲队列把数据缓冲下来，一个一个慢慢的处理，但缓冲队列也有限度，超出这个限度，缓冲队列容纳不下，包就会被丢掉。\n\n## 传输层\n\n传输层是只有计算机才有的层次，主要提供是进程间`逻辑通信` + `可靠传输`或者`不可靠`的功能。比如 QQ 视频聊天，这就是不同计算机之间，进程间的通信。\n\n这里简单说一下`可靠传输协议TCP` + `不可靠传输协议UDP`\n\n> TCP 面向连接，可靠，不提供广播和多播，而且时间延迟比较大，适用于大文件传输。 UDP 无连接，收到的报也不确认，但时间延迟小，适用于小文件。\n\n### 端口号有什么用\n\n端口号可以用来标识同一个主机上通信的不同应用程序（就是哪个应用程序在使用这个端口）。\n\n那为什么一个端口只能分配给一个应用程序，不能是多个呢？\n\n如果服务器有两个应用程序 A，B，分别启动了 A 服务和 B 服务，它们监听同一个端口，那有数据来的时候，服务器无法判断这个数据到底是给 A，还是给 B。\n\n### 用户数据报协议 UDP\n\nUDP 协议是参考模型中一种`无连接`的传输层协议，提供面向事务的简单不可靠信息传送服务。\n\n#### UDP 协议的特点\n\n- UDP 是`无连接`的，减少开销和发送数据之前的时间延迟。`TCP`的`三次握手和四次挥手`，这个是需要时间花销的，但是 UDP 没有这部分花销。\n- UDP 使用最`大努力交付`，即不保证可靠交付。那谁来保证可靠的交付呢？是由 UDP 的上一层协议，应用层来保证。\n- UDP 是`面向报文`的，适合一次性传输少量数据的网络应用。什么意思呢，如下图，UDP 这层，把应用层的全部内容作为自己的数据报部分，在 IP 层也只是加了一个 IP 首部，我们知道，在以太网，链路层上的数据如果超过 1500 字节，就会分片，所以网络层发现上面传输层给了太大的数据就会分片，加上 UDP 是不可靠的协议，这就加大了 UDP 的不可靠性，容易丢失，所以 UDP 适合数据量少的。\n\n![Alt text](/img/notes/2020-3-27_1_19.png)\n\n- UDP `没有拥塞控制`，适合很多实时应用。也就是说如果网络堵塞，UDP 不管那么多，照样按照自己的速率发数据，那有些人就会说，这协议是不是有点坑 B，路都堵上了，还发死劲发数据呢，但是反过来看，这也是 UDP 的优点，它允许丢包，如果你的网络情况还不错，UDP 就非常适合实时应用，比如视频会议。\n- UDP 支持一对一、一对多、多对一和多对多的交互通信。\n- UDP `首部较小`，只有 8 字节，而 TCP 由 20 字节。这也是减少网络传输开销的一方面。\n\n#### DUP 首部\n\n![Alt text](/img/notes/2020-3-27_1_20.png)\n\n- 16 位端口号占了 2B，也就是 16 位，说明端口号的范围是`0 - 65535`。源端口号可以没有，因为不希望收到对方的回应，可以写全 0，目的端口是一定要有的。\n- 16 位 UDP 长度是指`首部+数据的长度`，比如数据 2B，首部固定是 8B，那么 UDP 长度就是 2+8 = 10B\n- 16 位 UDP 校验和，是用来校验`首部和数据有错误`，如果有错就丢弃掉。比如说目的主机找不到对应的端口号，就会给发送方返回一个 ICMP，`端口不可达`的差错报文。\n\n### 传输控制协议 TCP\n\nTCP 协议简单来说是一种位于传输层的，面向连接的、可靠的、基于字节流的传输层通信协议。\n\n#### TCP 协议的特点\n\n- TCP 是`面向连接`的传输层协议。比如说 TCP 的三次握手，四次分手，针对的都是连接。\n- 每一条 TCP 连接`只能有两个端点`，每一条 TCP 连接是点对点的。也就是说 TCP 是不同计算机之间的进程的通信。\n- TCP 提供`可靠交付`的服务，无差错，不丢失，不重复，按序到达。总结一下就是，`可靠有序，不丢不重`。\n- TCP 提供`全双工通信`。全双工指的是连接双方可以同时收发数据。在收发两端都有发送缓存和接收缓存，发送缓存就是一个准备发送的队列，接收缓存是一个准备接收的队列。\n- TCP `面向字节流`。如下图。\n\n![Alt text](/img/notes/2020-3-27_1_21.png)\n\n图中的 1，2，3，4.....数据块，每一个表示一个字节。TCP 将应用层的数据变为了这样的字节进行发送，比如 node 中的 buffer 就是字节流。\n\n#### TCP 首部\n\n如下图所示，我们看一下比较重要的一些首部字段，这里我们介绍`固定的20字节`的 TCP 首部。\n\n![Alt text](/img/notes/2020-3-27_1_22.png)\n\n- 源端口和目的端口分别是指发送方应用程序的端口和目的方应用程序的端口号。\n- 序号是指在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，本字段表示`本报文段所发送数据的第一个字节的序号`。\n- 确认号是指`期望收到对方下一个报文段的第一个数据字节的序号` 。若确认号为 N，则证明到需要 N-1 为止所有的数据都已经正确收到。\n- 数据偏移指的是 TCP 报文段的数据起始距离 TCP 报文段的起始处有多远。\n\n- 6 个控制位介绍：\n  | 控制位 | 作用                                                                              |\n  | ------ | --------------------------------------------------------------------------------- |\n  | ACK    | 置 1 时表示确认号合法，为 0 的时候表示数据段不包含确认信息，确认号被忽略          |\n  | PSH    | 置 1 时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送 |\n  | RST    | 置 1 时重建连接。如果接收到 RST 位时候，通常发生了某些错                          |\n  | SYN    | 置 1 时用来发起一个连接                                                           |\n  | FIN    | 置 1 时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了           |\n  | URG    | 紧急指针，告诉接收 TCP 模块紧要指针域指着紧要数据                                 |\n\n#### TCP 建立连接\n\n如下图所示：\n\n![Alt text](/img/notes/2020-3-27_1_23.png)\n\n1. 首先客户端要发送一个数据报告诉服务器要建立连接，根据上面了解到的控制位信息，建立连接需要把`SYN置为1`，同时选择一个初始序号`seq`，是随机产生的。TCP 规定，`SYN=1`的报文段不能携带数据，但要消耗一个序号。\n2. 然后服务器收到该数据报后，会为该 TCP 连接分配缓存和变量，缓存指的是一个字节流队列。（发送方和接收方都有这个队列，而且如果双方需要互相通信，那么双方都会有发送缓存和接收缓存），接着会返回一个确认报文，其中 `SYN 控制位置为 1`，意思是允许建立连接，`ACK 也置为1`，确认收到了发送方的报，并且会设一个 seq ，也为一个随机数。小写 ack 是确认号，也就是接下来希望发送方要发的数据从哪开始, `ack=x+1`。\n3. 最后，客户端需要给服务器端返回一个确认，此时 SYN 控制位变为 0，意思这不是建立连接的请求了，要正式发数据了，ACK 是确认码，意思是收到了服务器的确认请求了。\n\n若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据报。\n\n#### TCP 释放连接\n\n如下图所示：\n\n![Alt text](/img/notes/2020-3-27_1_24.png)\n\n- 客户端发起请求，请求断开链接。`FIN=1，seq=u`。u 是之前传送过的数据的最后一个字节的序号+1。FIN：用来释放一个链接，当`FIN=1`的时候，表明此报文的发送方已经完成了数据的发送，没有新的数据要传送，并要求释放链接。客户端等着服务器返回确认。FIN 报文段即使不携带数据，也消耗掉一个序号。\n- 服务器收到客户端的请求断开链接的报文之后，返回确认信息。`ACK=1，seq=v，ack=u+1`。这个时候，客户端不能给服务器发送信息报文，只能接收。但是服务器要是还有信息要传给服务器，仍然能传送。\n- 当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。`FIN=1，ACK=1，ack=u+1，seq=w`。这里的 w，跟上面的 v 是一个意思，为什么不都是 v 呢，因为这一步和上一步中间可能还在发数据呢，所以 seq 这个数据发送的字节流序号可能要变。\n- 客户端接收到`FIN=1`的报文之后，返回确认报文，`ACK=1，seq=u+1，ack=w+1`。发送完毕之后，客户端进入等待状态，等待两个时间周期。关闭。\n\n为什么最后还要等待两个时间周期呢？\n\n![Alt text](/img/notes/2020-3-27_1_25.png)\n\n#### 相关问题\n\n1、三次是最小的安全次数，可以保证通信的双方都具有发送消息和接收响应的能力，发送方和接收方始终同步序号，可以实现可靠传输。\n\n![Alt text](/img/notes/2020-3-27_1_26.png)\n\n2、如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\n`TCP保活计时器` 每次客户端请求服务器会重置计时器，当`2小时之内`没收到客户端任何数据时，会每隔`75s`向客户端发一个探测报文，若接连发送`10`个，客户端都没有反应，则认为客户端故障，关闭连接。\n\n3、什么是 SYN 洪泛攻击？\n\nSYN 洪泛攻击就是利用 TCP 协议的特性（三次握手）。攻击者发送 TCP 的 SYN，SYN 是 TCP 三次握手中第一个数据报，而当服务器返回 ACK 后，该攻击者就不对其进行再确认，那这个 TCP 连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复发送 ACK 给攻击者。这样更加会浪费服务器资源。攻击者就对服务器发送大量的这种 TCP 连接，由于每一个连接都无法完成三次握手，所以就在服务器上，这些 TCP 连接会因为挂起状态而消耗 CPU 和内存，最后服务器可能死机。\n\n4、序号为什么要随机？\n\n增加安全性，为了避免被第三方猜测到，从而被第三方伪造的 RST 报文 Reset。\n\n5、三次握手的第一次可以携带数据吗？为何？\n\n不可以，三次握手还没有完成。而且这样会放大`SYN FLOOD`（SYN 洪泛）攻击。\n如果攻击者伪造了成千上万的握手报文，携带了 1K+ 字节的数据，而接收方会开辟大量的缓存来容纳这些巨大数据，内存会很容易耗尽，从而拒绝服务。\n\n6、三次握手的第三次可以携带数据吗？为何？\n\n第三次握手，此时客户端已经处于`ESTABLISHED`状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。\n\n#### TCP 如何实现可靠传输\n\n主要通过以下四种方式实现可靠传输机制：\n\n- 校验。伪首部是为了增加 TCP 校验和的检错能力：通过伪首部的目的 IP 地址来检查 TCP 报文是否收错了、通过伪首部的传输层协议号来检查传输层协议是否选对了。需要注意的是，伪首部实际上是不存在的，只是用来验证 TCP 报文是否出错。\n- 序号。之前我们提到 TCP 是面向字节流的，比如第一个字节就是序号 1，第二个字节就是序号 2。 而在 TCP 报文格式介绍的时候，有一个序号字段，这个指的是一个报文段第一个字节的序号。报文段就是你每个数据包。有了序号，就能保证数据是有序的传入应用层。\n- 确认。发送方在收到接收方的确认报 之后，才继续发送剩下的数据。\n- 重传。TCP 的发送方在规定的时间内没有收到确认就要重传已发送的报文段（超时重传）。重传时间是动态改变的，依据的是 RTTS（加权平均往返时间）。\n\n#### TCP 的流量控制\n\n比如发送方发送速度非常快，接收方接收速度特别慢，这样就会发生严重的丢包现象。\n\nTCP 通过滑动窗口的机制来实现流量控制。简单来说如下：\n\n- TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。\n- 当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。\n\n#### TCP 的拥塞控制\n\n- 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。\n- TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。\n- 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。\n\n为了便于讨论，做如下假设：\n\n- 接收方有足够大的接收缓存，因此不会发生流量控制；\n- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。\n\n慢开始与拥塞避免：\n\n- 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...\n- 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。\n\n如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。\n\n快重传与快恢复：\n\n- 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。\n- 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。\n- 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。\n- 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。\n\n## 应用层\n\n### 应用层作用\n\n应用层对应用程序的通信提供服务。\n\n- 区分是发送报文还是接收报文\n- 定义报文类型的语法，比如某字段的意思，例如 http 中 content-type 字段是什么意思。\n- 最后就是进程如何，什么时候把传输层的数据交给应用层。\n\n一些比较重要的应用层协议如下图：\n\n![Alt text](/img/notes/2020-3-27_1_27.png)\n\n### 应用层常见的模型\n\n第一种是客户端/服务器模型，也就是 C/S 架构。比如电子邮件、web 都是。\n\n![Alt text](/img/notes/2020-3-27_1_28.png)\n\n第二种是 P2P 模型，每个主机既可以提供服务，也可以请求服务。比如迅雷下载也是使用 P2P 技术的。\n\n![Alt text](/img/notes/2020-3-27_1_29.png)\n\n### 短链接和长链接\n\nTCP 连接有两种工作方式：短连接方式（Short-Live Connection）和长连接方式（Long-Live Connection）。\n\n短连接方式：\n\n当客户端有请求时，会建立一个 TCP 连接，接收到服务器响应后，就断开连接。下次有请求时，再建立连接，收到响应后，再断开。如此循环。这种方式主要有两个缺点：\n\n- 建立 TCP 连接需要 3 次“握手”，拆除 TCP 连接需要 4 次“挥手”，这就需要 7 个数据报。如果请求和响应各占 1 个数据报，那么一次短连接的交互过程，有效的传输仅占 2/9，这个利用率太低了。\n- 主动断开 TCP 连接的一端，TCP 状态机会进入`TIME_WAIT`状态。如果频繁地使用短连接方式，就有可能使客户端的机器产生大量的处于`TIME_WAIT`状态 TCP 连接。\n\n长连接方式：\n客户端和服务器建立 TCP 连接后，会一直使用这条连接进行数据交互，直到没有数据传输或异常断开。在空闲期间，通常会使用`Keep-Alive`保持链路不断开。目前长连接方式应用范围比较广泛。\n\n#### 持久连接\n\n`Keep-Alive`是`http/1.1`增加的。 在没有`Keep-Alive`之前，HTTP 请求都是短连接，就是说每一次请求都要建立连接，请求完成后马上关闭连接，也就是我们上面说的三次握手和四次挥手过程，每次请求都要建立连接带来了资源的浪费，为了提高请求效率，于是有了`Keep-Alive`。\n\n`Keep—Alive`允许在一定时间内，同一个域名多次请求数据，只建立一次 HTTP 连接，其他请求可以复用这个连接通道，以达到提高请求效率的目的。\n\n持久连接使得多数请求以`管状化`方式成为可能。以前发送请求后需要等待并收到响应，才能发送下一个请求。管状化技术出现后，不用等待响应也可直接发送下一个请求。\n\n### DNS\n\nDNS 就是将域名转化为 IP，比如 `www.qq.com`，这是域名，可以是网络报需要对方 IP 地址，域名是不能加入网络报报头的，所以就需要去找一个服务器问，qq 的域名对应的 IP 是多少。\n\n大概的通信过程如下：\n\n1. 用户主机上运行着`DNS`的客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端了\n2. 浏览器将接收到的 url 中抽取出域名字段，就是访问的主机名，比如 `http://www.baidu.com/` , 并将这个主机名传送给 DNS 应用的客户端\n3. DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式 DNS 集群的工作）\n4. 该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址\n5. 一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接\n\n### 万维网和 HTTP 协议\n\n万维网 www 是一个大规模的、联机式的信息存储所，是无数个网络站点和网页的集合。`互联网包含因特网，因特网包含万维网`。\n\n- `互联网internet`。凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分，国际标准的互联网写法是 internet，字母 i 一定要小写！\n- `因特网Internet`。而因特网是互联网中的一种，它可不是仅有两台机器组成的网络，而是由上千万台设备组成的网络（该网络具备很大的规模）。因特网使用 TCP/IP 协议让不同的设备可以彼此通信。但使用 TCP/IP 协议的网络并不一定是因特网，一个局域网也可以使用 TCP/IP 协议。\n- 因特网是基于 TCP/IP 协议实现的，TCP/IP 协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如 FTP、SMTP、HTTP。所以，因特网提供的服务一般包括有：www（万维网）服务、电子邮件服务（outlook）、远程登录（QQ）服务、文件传输（FTP）服务、网络电话等等。\n- `万维网`。只要应用层使用的是 HTTP 协议，就称为万维网(World Wide Web)。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是 HTTP 协议在交流。\n\n万维网使用统一资源定位符 URL 作为标识符来访问资源。\n\nURL 的格式如下：\n\n![Alt text](/img/notes/2020-3-27_1_30.png)\n\n用户通过点击超链接获取资源，这些资源通过超文本传输协议（HTTP）传送给使用者。\n\nHTTP 协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。\n\n![Alt text](/img/notes/2020-3-27_1_31.png)\n\n### HTTP 常用状态码\n\n- `200 OK`表示从客户端发来的请求被正常处理了。\n- `204 No Content`表示服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回实体的主体。比如`OPTIONS`请求。\n- `206 Partial Content`表示客户端进行了范围请求，而服务器成功执行了这部分请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n- `301 Moved Permanently`永久重定向。表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。\n- `302 Found`临时性重定向。表示请求的资源已被分配了新的 URI，希望用户本次能使用新的 URI 访问。\n- `303 See Other`表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。`303`和`302`有着相同的功能，但`303`明确表示客户端应该用`GET`的方法获取资源。\n- `304 Not Modified`表示客户端发送附带条件（GET 方法的请求报文中包含 If-Match, If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since 中的任一首部）的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回`304`。`304`返回时，不包含任何响应的主体部分。\n- `307 Temporary Redirect`临时重定向。`307`会遵照浏览器标准，不会从`POST`变成`GET`。\n- `400 Bad Request`表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。浏览器会像`200`一样对待该状态码。\n- `401 Unauthorized`表示发送的请求需要有通过 HTTP 认证的认证信息。\n- `403 Forbidden`表示对请求资源的访问被服务器拒绝了。\n- `404 Not Found`表明服务器上无法找到请求的资源。\n- `500 Internal Server Error`表明服务器端在执行请求时发生了错误。\n- `503 Service Unavailable`表明服务器暂时处于超负载或在进行停机维护，现在无法处理请求。\n\n### HTTP 缺点\n\n- 通信使用明文（不加密），内容可能会被窃听\n- 不会验证通信方的身份，因此可能会遭遇伪装\n- 无法保证报文的完整性，请求或响应的内容被篡改也无法知道\n\n### HTTPS\n\nHTTPS = HTTP + 加密 + 身份验证 + 数据完整性保护\n\nHTTPS 和 HTTP 区别：\n\n- HTTP 使用明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议\n- HTTP 不会验证通信方的身份，HTTPS 会通过数字证书来验证身份\n- HTTPS 可以保证数据的完整性，防止传输内容被中间人冒充或篡改\n- 除以上外，HTTP 和 HTTPS 使用的端口也不同，前者使用 80 端口，后者使用 443 端口\n\n### HTTP/2.0\n\n相关概念：\n\n- 帧： HTTP/2 数据通信的最小单位。每个帧都包含帧首部，其中会标识当前帧所属的流。\n- 消息： 指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。 、\n- 流： 存在于连接中的虚拟通道。流可以承接双向消息，每个流都有一个唯一的整数 id。\n- 连接： 与 HTTP/1 相同，都是指对应的 TCP 连接。\n\nHTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。而 HTTP/2 将请求和响应数据分隔成为更小的帧，并对他们采用二进制编码。\n\n相比 HTTP/1 的优化：\n\n- 提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 HTTP/1）\n- 允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 HTTP/1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。\n- 二进制分帧：HTTP/2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码\n- 首部压缩\n- 服务器端推送\n\nHTTP/2 中，同域名下的所有请求都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，消息由一个或多个帧组成。多个帧之间可以乱序发送，然后根据帧首部的流标识可以重新组装。\n\n### WebSocket 协议\n\n主要特点：\n\n- 推送功能\n- 减少通信量\n\n握手-请求\n\n```plain\nUpgrade: websocket\nConnection: Upgrade\n```\n\n握手-响应\n\n```plain\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\n```\n\n### 在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？\n\n1. 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 HTTP 协议就按照 Web 方式来处理。\n\n2. 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法。\n\n3. 然后去找到这个 URL 对应的 IP 地址,为了寻找这个 IP 地址，浏览器首先会查找：浏览器缓存 -> 操作系统缓存 -> 本地 host 文件 -> 路由器缓存 -> DNS 服务器。\n\n    `DNS 负载均衡`： 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用 DNS 负载均衡技术，它的原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址,在应答 DNS 查询时,DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。\n\n4. 拿到域名对应的 IP 地址之后，浏览器根据这个 IP 地址以及相应的端口号会向服务器发起 TCP 的连接请求。\n\n5. 发送 HTTP 请求。\n\n6. 服务器处理请求。\n\n    一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过 HTTP 协议访问某网站应用服务器，而是先请求到 Nginx，Nginx 再请求应用服务器，然后将结果返回给客户端，这里 Nginx 的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。\n\n7. 服务器返回一个 HTTP 响应。\n\n    > 使用[缓存](/2021/05/14/RESTful-API/)\n\n8. 浏览器解析渲染页面。\n\n    浏览器是一个边解析边渲染的过程。首先浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和 repain(重绘)。DOM 节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为 repain。页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。\n\n    > [重绘 repain 和重排(回流)reflow 以及优化方法](<./性能相关.md#重绘repain和重排(回流)reflow以及优化方法>)\n\n    当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。因为 JS 有可能会修改 DOM，最为经典的 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的根本原因。所以我明平时的代码中，js 是放在 html 文档末尾的。\n\n    JS 的解析是由浏览器中的 JS 解析引擎完成的。JS 是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。\n\n    JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。\n\n9. 连接结束\n    ​\n    现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭。\n","slug":"计算机网络","published":1,"updated":"2021-06-23T07:45:21.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr90alo10004as7i7d0zdg8x","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p>\n<p>按分布范围，计算机网络里有<code>局域网LAN</code>和<code>广域网WAN</code>, 其中局域网的代表以太网，以及这两种网络最重要的区分点，局域网基于<code>广播技术</code>，广域网基于<code>分组交换</code>技术。</p>\n<h3 id=\"网络的网络\"><a href=\"#网络的网络\" class=\"headerlink\" title=\"网络的网络\"></a>网络的网络</h3><p>网络把主机连接起来，而互连网<code>internet</code>是把多种不同的网络连接起来，因此互连网是网络的网络。而英特网<code>Internet</code>是全球范围的互连网。</p>\n<h3 id=\"ISP\"><a href=\"#ISP\" class=\"headerlink\" title=\"ISP\"></a>ISP</h3><div class=\"note note-primary\">\n            <p>ISP (Internet service provider) 互联网服务提供商</p>\n          </div>\n\n<p><code>ISP</code>可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向<code>ISP</code>缴纳一定的费用就可以接入互联网。</p>\n<p>目前的互联网是一种多层次<code>ISP</code>结构，<code>ISP</code>根据覆盖面积的大小分为第一层<code>ISP</code>、区域<code>ISP</code>和接入<code>ISP</code>。互联网交换点 IXP 允许两个<code>ISP</code>直接相连而不用经过第三个<code>ISP</code>。</p>\n<h3 id=\"主机之间的通信方式\"><a href=\"#主机之间的通信方式\" class=\"headerlink\" title=\"主机之间的通信方式\"></a>主机之间的通信方式</h3><ul>\n<li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li>\n<li>对等（P2P）：不区分客户和服务器。</li>\n</ul>\n<h3 id=\"电路交换与分组交换\"><a href=\"#电路交换与分组交换\" class=\"headerlink\" title=\"电路交换与分组交换\"></a>电路交换与分组交换</h3><ul>\n<li><p>电路交换</p>\n<p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>\n</li>\n<li><p>分组交换</p>\n<p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>\n</li>\n</ul>\n<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>\n<h3 id=\"衡量计算机网络的性能的指标\"><a href=\"#衡量计算机网络的性能的指标\" class=\"headerlink\" title=\"衡量计算机网络的性能的指标\"></a>衡量计算机网络的性能的指标</h3><h4 id=\"速率\"><a href=\"#速率\" class=\"headerlink\" title=\"速率\"></a>速率</h4><p>速率就是数据传输（数据是指 0 和 1）的速率，比如用迅雷下载，1 兆每秒，来衡量目前数据传输的快慢。它是计算机网络中最重要的一个性能指标。</p>\n<h4 id=\"带宽\"><a href=\"#带宽\" class=\"headerlink\" title=\"带宽\"></a>带宽</h4><p>在计算机网络中，网络带宽是指在单位时间（一般指的是 1 秒钟）内能传输的数据量，比如说你家的电信网络是 100 兆比特，意思是，一秒内最大的传输速率是 100 兆比特。</p>\n<h4 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h4><p>吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。</p>\n<div class=\"note note-primary\">\n            <p>由此可知带宽说的是最大值速率，吞吐量说的是某时刻速率。但吞吐量不能超过最大速率</p>\n          </div>\n\n<h4 id=\"时延\"><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h4><p>时延是指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。单位是 s。 时延分以下几种：</p>\n<ul>\n<li>排队时延：分组在经过网络传输时，要经过很多的<code>路由器</code>。但分组在进入路由器后要先在输入队列中<code>排队等待</code>处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发，这就产生了<code>排队时延</code>。排队时延的长短往往却决于网络当时的通信量，当网络的通信量很大时会发生排队溢出，是<code>分组丢失</code>。</li>\n<li>处理时延：<code>路由器</code>或<code>主机</code>在收到数据报时，要花费一定时间进行处理，例如<code>分析数据报的首部</code>、进行<code>首部差错检验</code>，<code>查找路由表</code>为数据报选定准发接口，这就产生了处理时延。</li>\n<li>发送时延：主机或路由器传输数据帧所需要的时间。</li>\n<li>传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</li>\n</ul>\n<div class=\"note note-primary\">\n            <p>总时延 = 排队时延 + 处理时延 + 发送时延 + 传播时延</p>\n          </div>\n\n<h4 id=\"往返时间（RTT）\"><a href=\"#往返时间（RTT）\" class=\"headerlink\" title=\"往返时间（RTT）\"></a>往返时间（RTT）</h4><p>在计算机网络中，往返时间也是一个重要的性能指标，它表示从发送方发送数据开始，到发送方收到来自接收方的确认（接受方收到数据后便立即发送确认）总共经历的时间。</p>\n<h4 id=\"时延带宽积\"><a href=\"#时延带宽积\" class=\"headerlink\" title=\"时延带宽积\"></a>时延带宽积</h4><p>是指传播时延乘以带宽。</p>\n<h3 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h3><p><img src=\"/img/notes/2020-3-27_1_32.png\" alt=\"计算机网络体系结构\"></p>\n<h4 id=\"五层协议\"><a href=\"#五层协议\" class=\"headerlink\" title=\"五层协议\"></a>五层协议</h4><ul>\n<li>应用层：为特定应用程序提供数据传输服务，例如<code>HTTP</code>、<code>DNS</code>等协议。数据单位为报文。</li>\n<li>传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议<code>TCP</code>，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 <code>UDP</code>，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。<code>TCP</code>主要提供完整性服务，<code>UDP</code>主要提供及时性服务。</li>\n<li>网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>\n<li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>\n<li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>\n</ul>\n<h4 id=\"OSI\"><a href=\"#OSI\" class=\"headerlink\" title=\"OSI\"></a>OSI</h4><div class=\"note note-primary\">\n            <p>OSI (Open System Interconnection Model)</p>\n          </div>\n\n<p>如下图所示，1、2、3 层主要是<code>物理链路</code>组成的，比如<code>光纤</code>，<code>路由器</code>，<code>集线器</code>，主要负责的是<code>数据通信</code>。5、6、7 层是<code>软件控制</code>的，比如<code>HTTP</code>协议，是一种软件层面控制的协议，主要负责处理传输来的<code>数据</code>。</p>\n<p><img src=\"/img/notes/2020-3-27_1_1.png\" alt=\"OSI\"></p>\n<p>其中表示层和会话层用途如下:</p>\n<ul>\n<li><p>表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>\n</li>\n<li><p>会话层：建立及管理会话。</p>\n</li>\n</ul>\n<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>\n<h4 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h4><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>\n<p><code>TCP/IP</code>体系结构不严格遵循<code>OSI</code>分层概念，应用层可能会直接使用IP层或者网络接口层。</p>\n<h4 id=\"数据在各层之间的传递过程\"><a href=\"#数据在各层之间的传递过程\" class=\"headerlink\" title=\"数据在各层之间的传递过程\"></a>数据在各层之间的传递过程</h4><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>\n<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><h3 id=\"物理层作用\"><a href=\"#物理层作用\" class=\"headerlink\" title=\"物理层作用\"></a>物理层作用</h3><p>对于物理层，有人会说，这不就是网线吗，比如家里连接路由器的网线，电线杆上的光纤？其实不然，物理层更多的是规定一种标准，他并不管物理介质具体是什么，比如电线杆上是光纤还是双绞线，只要你能按物理层规定的标准传输数据就行。</p>\n<div class=\"note note-primary\">\n            <p>物理层是规定传输媒体接口的标准</p>\n          </div>\n\n<h3 id=\"通信方式\"><a href=\"#通信方式\" class=\"headerlink\" title=\"通信方式\"></a>通信方式</h3><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>\n<ul>\n<li>单工通信：单向传输。</li>\n<li>半双工通信：双向交替传输。是指允许数据在两个方向上传输，但是在某一时刻只允许数据在一个方向上传输。</li>\n<li>全双工通信：双向同时传输。</li>\n</ul>\n<h3 id=\"光纤宽带上网的传输数据形式\"><a href=\"#光纤宽带上网的传输数据形式\" class=\"headerlink\" title=\"光纤宽带上网的传输数据形式\"></a>光纤宽带上网的传输数据形式</h3><ul>\n<li>首先计算机网卡传输出来的数据是<code>电信号</code>，光纤传输的是<code>光脉冲</code>信号，有光脉冲表示<code>1</code>，无光脉冲表示<code>0</code>。</li>\n<li>而可见光的频率大约是<code>10的8次方MHz</code>，因此光纤通信系统的带宽远远大于其它各种传输媒体的带宽</li>\n<li>所以我们计算机传输数据需要先把<code>电信号</code>转为<code>光信号</code>，然后<code>光信号</code>快到服务器的时候，再把<code>光信号</code>转为<code>电信号</code>。</li>\n</ul>\n<h3 id=\"物理层设备中继器\"><a href=\"#物理层设备中继器\" class=\"headerlink\" title=\"物理层设备中继器\"></a>物理层设备中继器</h3><p>为什么需要中继器呢？因为再线路上传输的信号功率会<code>逐渐衰减</code>，衰减到一定程度时将造成<code>信号失真</code>，因此会导致接收错误。中继器可以对信号进行<code>再生</code>和<code>还原</code>，增加信号的传输距离。</p>\n<p>需要注意的是，中继器两端连接不同的网段，而不是子网。</p>\n<h2 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h2><h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><ul>\n<li>封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。封装的网络数据报，在链路层就叫<code>数据帧</code>。</li>\n<li>透明传输：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</li>\n<li>差错控制：在文件送到 B 公司小秘书手里的时候，快递包上写着 5 个文件，秘书一看只有 3 个文件，就会让物理层重新发送有没有送到的文件。目前数据链路层广泛使用了<code>CRC循环冗余检验</code>来检查比特差错。</li>\n<li>差错纠正：链路层知道 1，2，3，4，5 个文件，丢失的两个文件到底是哪两个，并且能通过重新发送没有的文件来纠正。</li>\n<li>流量控制：比如说发送方发送速度特别快，接收方接收速度特别慢，会造成传输出错。</li>\n</ul>\n<p>这里需要注意的是，传输层 TCP 也有流量控制功能，区别在于 TCP 是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）流量控制的方法有滑动窗口协议，以及选择重传协议。</p>\n<h3 id=\"通信分类\"><a href=\"#通信分类\" class=\"headerlink\" title=\"通信分类\"></a>通信分类</h3><h4 id=\"广播信道\"><a href=\"#广播信道\" class=\"headerlink\" title=\"广播信道\"></a>广播信道</h4><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p>\n<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>\n<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>\n<h4 id=\"点对点信道\"><a href=\"#点对点信道\" class=\"headerlink\" title=\"点对点信道\"></a>点对点信道</h4><p>一对一通信。</p>\n<p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p>\n<h3 id=\"CSMA-CD-协议\"><a href=\"#CSMA-CD-协议\" class=\"headerlink\" title=\"CSMA/CD 协议\"></a>CSMA/CD 协议</h3><p><code>CSMA/CD</code>表示载波监听多点接入/碰撞检测。</p>\n<ul>\n<li>多点接入：说明这是总线型网络（半双工），许多主机以多点的方式连接到总线上。</li>\n<li>载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>\n<li>碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>\n</ul>\n<h3 id=\"PPP-协议\"><a href=\"#PPP-协议\" class=\"headerlink\" title=\"PPP 协议\"></a>PPP 协议</h3><p>互联网用户通常需要连接到某个<code>ISP</code>之后才能接入到互联网，<code>PPP</code>协议是用户计算机和<code>ISP</code>进行通信时所使用的数据链路层协议。</p>\n<p>PPP 的帧格式：</p>\n<ul>\n<li>F 字段为帧的定界符</li>\n<li>A 和 C 字段暂时没有意义</li>\n<li>FCS 字段是使用 CRC 的检验序列</li>\n<li>信息部分的长度不超过 1500</li>\n</ul>\n<h3 id=\"MAC地址\"><a href=\"#MAC地址\" class=\"headerlink\" title=\"MAC地址\"></a>MAC地址</h3><p><code>MAC地址</code>是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>\n<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>\n<h3 id=\"局域网\"><a href=\"#局域网\" class=\"headerlink\" title=\"局域网\"></a>局域网</h3><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>\n<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>\n<p>可以按照网络拓扑结构对局域网进行分类：</p>\n<p><img src=\"/img/notes/2020-3-27_1_33.png\" alt=\"局域网拓扑结构\"></p>\n<h3 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h3><p>以太网是一种<code>局域网</code>技术，其规定了<code>访问控制方法</code>、<code>传输控制协议</code>、<code>网络拓扑结构</code>、<code>传输速率</code>等，完成数据链路层和物理层的一些内容，它采用一种称作<code>CSMA/CD</code>的媒体接入方法，另外的一些局域网技术，比如无线局域网等。</p>\n<h4 id=\"以太网的帧格式\"><a href=\"#以太网的帧格式\" class=\"headerlink\" title=\"以太网的帧格式\"></a>以太网的帧格式</h4><p><img src=\"/img/notes/2020-3-27_1_2.png\" alt=\"以太网的帧格式\"></p>\n<ul>\n<li>其中<code>目的地址</code>和<code>源地址</code>指的是<code>MAC地址</code>，即设备的物理地址。<code>MAC地址</code>用于标示网卡，每个网卡都具有唯一的<code>MAC地址</code>。</li>\n<li>当在同一个局域网中，主机<code>A</code>需要给主机<code>B</code>发送消息时，主机<code>A</code>将以太网帧发出，此时局域网中所有主机均可收到这个桢，主机中的网卡接收到以太网桢后，会将目的<code>MAC地址</code>和自己的<code>MAC地址</code>进行比较,如果不相同就会丢弃，如果相同则会接收，此时则<code>Ｂ</code>主机就收到了<code>Ａ</code>的消息。</li>\n<li>其最后面是<code>CRC循环冗余码</code>，用于差错控制，即检验帧的正确性。</li>\n<li>在以太网协议中，目的地址分为三种<code>单播地址</code>、<code>广播地址</code>、<code>多播地址</code>，其中<code>单播地址</code>如上面<code>Ａ</code>给<code>Ｂ</code>主机发送，其接收者为一个，并且其目的地址的最高字节的低位为<code>0</code>。</li>\n</ul>\n<h4 id=\"以太网的特点\"><a href=\"#以太网的特点\" class=\"headerlink\" title=\"以太网的特点\"></a>以太网的特点</h4><ul>\n<li>无连接。发送方和接收方不建立连接。</li>\n<li>不可靠。接收方不向发送方进行确认，差错帧直接丢弃。</li>\n</ul>\n<h4 id=\"以太网的拓扑结构\"><a href=\"#以太网的拓扑结构\" class=\"headerlink\" title=\"以太网的拓扑结构\"></a>以太网的拓扑结构</h4><p>跟以太网相关的拓扑结构有<code>星型</code>和<code>总线型</code>。</p>\n<p>互联网初期，以太网的<code>总线型拓扑</code>比较普遍。随着总线型以太网上的站点数目增多,<code>可靠性也会随之下降</code>,而随着大规模集成电路以及专门芯片的发展,使得<code>星型以太网变得便宜又可靠</code>。</p>\n<p>需要注意的是，以太网虽然物理上是<code>星型拓扑</code>，但逻辑上是<code>总线型</code>。</p>\n<h3 id=\"网卡\"><a href=\"#网卡\" class=\"headerlink\" title=\"网卡\"></a>网卡</h3><p>计算机传出的数据，经过网卡，就会变为<code>以太网的帧</code>，还会完成一些<code>链路管理</code>（CSMA/CD 的实现），以及<code>编码</code>和<code>译码</code>。</p>\n<h3 id=\"无线局域网\"><a href=\"#无线局域网\" class=\"headerlink\" title=\"无线局域网\"></a>无线局域网</h3><p>无线局域网 WLAN 是利用无线电波、激光和红外线等无线通信技术来构建的局域网。</p>\n<h3 id=\"链路层的设备\"><a href=\"#链路层的设备\" class=\"headerlink\" title=\"链路层的设备\"></a>链路层的设备</h3><h4 id=\"网桥\"><a href=\"#网桥\" class=\"headerlink\" title=\"网桥\"></a>网桥</h4><p>网桥根据<code>MAC帧</code>的目的地址进行转发和过滤。当网桥收到一个帧时，并不会向所有接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个口，或者是把它丢弃。</p>\n<p>这里需要注意的是，网桥连接的是不同的网段.</p>\n<h4 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h4><p>谈到交换机，就不得不提两个概念，<code>冲突域</code>和<code>广播域</code></p>\n<ul>\n<li>冲突域： 是指同一时间只能由一台设备发送信息的范围。</li>\n<li>广播域：如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为广播域</li>\n</ul>\n<p>也就是说，广播域可以跨网段，而冲突域只是发生的同一个网段。</p>\n<p>举个例子，公司里大家的电脑一般都是连接到交换机上，因为交换机可以隔离冲突域，冲突域的最大问题在于，同一时间只能有一台机器传输数据，公司那么多人，如果这样的话，传输数据速度太慢了。然后交换机再连接到路由器上，首先路由器能隔离广播域，其次不经过路由器，你的数据链路层上的包没办法进入到互联网里面去，路由器是网络层的设备。</p>\n<p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>\n<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>\n<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>\n<p><img src=\"/img/notes/2020-3-27_1_3.png\" alt=\"交换机交换表\"></p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><p>网络层主要任务是将<code>分组</code>从一台主机移动到另一台主机，从而提供了<code>主机到主机的通信服务</code>和各种形式的<code>进程到进程的通信</code>。</p>\n<p>分组：大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发动，这种小块就称作分组。</p>\n<h3 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h3><p>当<code>主机H1</code>要向另一<code>主机H2</code>发送数据（报文）时，首先将数据划分成若干个等长的分组，然后将这些分组一个接一个地发往里与<code>H1</code>相联的<code>路由A</code>,当<code>A</code>接到分组后，先放入缓冲区，再按一定的路由算法确定该分组下一步将发注哪个结点，如此一个结点一个结点传递，直到最终目的<code>H2</code>。</p>\n<p>这一段话比较啰嗦，简单来说分组就是<code>分数据块</code>，同时还具有<code>无需建立连接</code>，存储转发（存储转发是指以太网交换机的控制器先将输入端口到来的数据报缓存起来，先检查数据报是否正确，并过滤掉冲突包错误），<code>动态分配路线</code>（交换设备会根据网络状况选择不同的路线，比如路由器）的优点。</p>\n<h3 id=\"数据报\"><a href=\"#数据报\" class=\"headerlink\" title=\"数据报\"></a>数据报</h3><p>数据报是通过网络传输的<code>数据的基本单元</code>，包含一个<code>报头（header）</code>和<code>数据</code>本身。说白了，就是带地址的数据，比如你的写了一句微信”你好”，这串文字本上加上源地址，目的地址，就是数据报。</p>\n<h3 id=\"IP-数据报格式\"><a href=\"#IP-数据报格式\" class=\"headerlink\" title=\"IP 数据报格式\"></a>IP 数据报格式</h3><p><img src=\"/img/notes/2020-3-27_1_5.png\" alt=\"IP数据报格式\"></p>\n<ul>\n<li>首部的<strong>固定部分</strong>是<code>20字节</code>，共 <code>20 * 8 = 160</code> 比特（1 字节=8 比特）。</li>\n<li><strong>版本</strong>：占4位，有 4（IPv4）和 6（IPv6）两个值。</li>\n<li><strong>首部长度</strong>：<code>单位是 4B</code>，最小为 5，因为首部至少 20 字节，所以 4 * 5 就是 20 字节。</li>\n<li><strong>区分服务</strong> ：用来获得更好的服务，一般情况下不使用。</li>\n<li><strong>总长度</strong>：首部长度+数据部分长度。</li>\n<li><strong>标识</strong>： 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>\n<li><strong>片偏移</strong> ：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>\n<li><strong>生存时间</strong>：<code>TTL</code>，它告诉网络，数据报在网络中的时间是否太长而应被丢弃。以路由器跳数为单位，每经过一个路由器减一，变成 0 就丢弃。</li>\n<li><strong>协议</strong>：是指数据部分用的什么协议，我们只需要知道<code>TCP</code>协议用<code>6</code>表示，<code>UDP</code>协议用<code>17</code>表示即可。</li>\n<li><strong>首部校验和</strong>：这个字段只检验数据报的首部，不包括数据部分，因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>\n<li><strong>目的地址</strong>和<strong>源地址</strong>都是<code>IP地址</code>，目的地址是通过<code>DNS</code>查询得来的。</li>\n</ul>\n<h3 id=\"IP-分片\"><a href=\"#IP-分片\" class=\"headerlink\" title=\"IP 分片\"></a>IP 分片</h3><p>为什么需要分片：链路层数据帧封装的数据大小是有限制的，以太网的 MTU（MTU 是指一种通信协议的某一层上面所能通过的最大数据报大小）是 1500 字节。</p>\n<p>在 IP 数据报上，标识了分片的数据的字段：</p>\n<p><img src=\"/img/notes/2020-3-27_1_7.png\" alt=\"IP数据报格式\"></p>\n<ul>\n<li><strong>标识</strong></li>\n<li><strong>标志</strong>：占 3 位，但只有两位有意义，第一个位叫<code>MF(More Fragment)</code>，MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。中间的一位记为<code>DF(Don’t Fragment)</code>，意思是“不能分片”。只有当 DF=0 时才允许分片。</li>\n<li><strong>片偏移</strong>：较长的分组在分片后，某片在原分组中的相对位置。</li>\n</ul>\n<p><img src=\"/img/notes/2020-3-27_1_34.png\" alt=\"数据报的分片举例\"></p>\n<h3 id=\"IP-地址分类\"><a href=\"#IP-地址分类\" class=\"headerlink\" title=\"IP 地址分类\"></a>IP 地址分类</h3><p><img src=\"/img/notes/2020-3-27_1_6.png\" alt=\"IP地址分类\"></p>\n<p>其中<code>127.0.0.0~127.255.255.255</code>用于环回测试。</p>\n<p>有一部分叫<code>私有IP地址</code>，是不能拿到网络上跟别的计算机通信的。只能是局域网自己内部用。比如说有：</p>\n<p><img src=\"/img/notes/2020-3-27_1_8.png\" alt=\"私有IP地址\"></p>\n<p>可以看到，C 类私有地址就是<code>192.168</code>网段，每个局域网都可以有这些私有 IP。</p>\n<p>还有一些<code>特殊地址</code>，需要了解：</p>\n<p><img src=\"/img/notes/2020-3-27_1_9.png\" alt=\"特殊地址\"></p>\n<p>注意，这里的全 1 是指，IPV4 地址由 4 个字节组成，每一个字节是 8 位，8 位全一就是十进制的 255, 即<code>255.255.255.255</code>。</p>\n<ul>\n<li>第一行，全一，代表是<code>255.255.255.255</code>，在本网络的目的地址写这个的话，就会内网广播。</li>\n<li>第二行，网络号特定值，主机号是全 0，比如，<code>192.169.10.1</code>，这是 c 类网络，所以网络号是<code>192.169.10</code>，主机号是 1，当主机号全 0 时，就是 0，表示<code>192.169.10.0</code>这个网段。</li>\n<li>第三行，还是<code>192.169.10.1</code>这个 c 类地址，主机号都是 1，也就是 8 个 1，代表 255，所以 <code>192.169.10.255</code>表示本网段的广播地址。</li>\n<li>第四行，127 作为网络号，主机号非全 0 或 1，比如说<code>127.0.0.1</code>代表本机，称为环回地址。</li>\n</ul>\n<p>IPV4 中，<code>0.0.0.0</code>地址被用于表示一个无效的，未知的或者不可用的目标。在服务器中，<code>0.0.0.0</code>指的是本机上的所有 IPV4 地址，如果一个主机有两个 IP 地址，<code>192.168.1.1</code>和<code>10.1.2.1</code>，并且该主机上的一个服务监听的地址是<code>0.0.0.0</code>，那么通过两个 IP 地址都能够访问该服务。</p>\n<h3 id=\"网络地址转换-NAT\"><a href=\"#网络地址转换-NAT\" class=\"headerlink\" title=\"网络地址转换(NAT)\"></a>网络地址转换(NAT)</h3><p>在 IP 地址分类里面，我们知道私有 IP 地址是不能跟外网交互的，在小公司大多数计算机的地址都是<code>192.168</code>网段，都是私有 IP 地址，它是怎么跟外网交互数据的呢，这里就引出来一个知识点叫<code>网络地址转换NAT</code>。</p>\n<p><img src=\"/img/notes/2020-3-27_1_10.png\" alt=\"网络地址转换NAT\"></p>\n<p>如上图所示，<code>192.168.0.3</code>，<code>192.168.0.4</code>都是私有网段上的，它们无法跟外网通信，这个时候由于路由器安装了 NAT 软件，就可以将自己的 IP 地址，即路由器的 IP 地址<code>172.38.1.5</code>作为内网的代理，去访问外网，外网返回来的数据，经过路由转换，转换成内网的<code>192.168</code>网段的私有地址。</p>\n<h3 id=\"子网划分和子网掩码\"><a href=\"#子网划分和子网掩码\" class=\"headerlink\" title=\"子网划分和子网掩码\"></a>子网划分和子网掩码</h3><p>划分子网的方式是从网络的主机号借用若干位作为子网号，主机号也就相应减少了同样的位数。</p>\n<p><img src=\"/img/notes/2020-3-27_1_11.png\" alt=\"子网划分\"></p>\n<p>当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。</p>\n<p>我们将<code>145.13.0.0</code>这个网段划分了三个子网，其中一个是<code>145.13.3.0</code>，一个是<code>145.13.21.0</code>，问题来了，如果一个数据报来了，数据报要交给的 IP 地址是<code>145.13.3.10</code>，我们怎么知道给哪个子网呢？</p>\n<p>方法是将数据报的目的地址，跟子网的子网掩码相与预算（二进制与预算规则是，1 跟 1 得 1，其它为 0），也就是目的地址<code>145.13.3.10</code>跟子网<code>145.13.3.0</code>的子网掩码<code>255.255.255.0</code>的与预算，得到的结果是<code>145.13.3.0</code>，所以发送到的子网就是<code>145.13.3.0</code>。</p>\n<h3 id=\"地址解析协议ARP\"><a href=\"#地址解析协议ARP\" class=\"headerlink\" title=\"地址解析协议ARP\"></a>地址解析协议ARP</h3><p>以太网的帧的格式：</p>\n<p><img src=\"/img/notes/2020-3-27_1_2.png\" alt=\"以太网的帧格式\"></p>\n<p>上图有一个<code>源地址</code>和<code>目的地址</code>，这两个地址都是指的<code>MAC地址</code>，<code>MAC地址</code>是什么呢？简单说来就是两台相邻的路由器 A 和 B，A 怎么把数据传给 B 呢，它总要知道 B 的物理地址吧，物理地址就像门牌号一样，我要知道你住在哪里，才能把数据送过去吧？首先你肯定知道自己的<code>MAC地址</code>是多少，因为在网卡上有，问题在于，别人的<code>MAC地址</code>是多少？<code>ARP协议</code>就是来帮你找<code>MAC地址</code>的。</p>\n<h4 id=\"ARP协议的过程\"><a href=\"#ARP协议的过程\" class=\"headerlink\" title=\"ARP协议的过程\"></a>ARP协议的过程</h4><p><img src=\"/img/notes/2020-3-27_1_12.png\" alt=\"ARP协议的过程\"></p>\n<ol>\n<li>每台主机都会在自己的<code>ARP缓冲区</code>中建立一个<code>ARP列表</code>，以表示 <code>IP地址</code>和<code>MAC地址</code>的映射关系</li>\n<li>当源主机需要将一个数据报要发送到目的主机时，会首先检查自己<code>ARP列表</code>中是否存在该<code>IP地址</code>对应的 <code>MAC地址</code></li>\n<li>如果有，就直接将数据报发送到这个<code>MAC地址</code>；如果没有，就向本地网段发起一个 <code>ARP</code>请求的广播报，查询此目的主机对应的<code>MAC地址</code></li>\n<li>此<code>ARP</code>请求数据报里包括源主机的<code>IP地址</code>、<code>硬件地址</code>、以及<code>目的主机的IP地址</code>。网络中所有的主机收到这个<code>ARP请求</code>后，会检查数据报中的目的<code>IP</code>是否和自己的<code>IP地址</code>一致</li>\n<li>如果不相同就忽略此数据报；如果相同，该主机首先将发送端的<code>MAC地址</code>和 <code>IP地址</code>添加到自己的<code>ARP列表</code>中</li>\n<li>如果<code>ARP表</code>中已经存在该<code>IP</code>的信息，则将其覆盖，然后给源主机发送一个 <code>ARP响应数据报</code>，告诉对方自己是它需要查找的<code>MAC地址</code></li>\n<li>源主机收到这个<code>ARP响应数据报</code>后，将得到的目的主机的<code>IP地址</code>和<code>MAC地址</code>添加到自己的<code>ARP列表</code>中，并利用此信息开始数据的传输</li>\n<li>如果源主机一直没有收到<code>ARP响应数据报</code>，表示<code>ARP查询失败</code>。</li>\n</ol>\n<h3 id=\"DHCP-协议\"><a href=\"#DHCP-协议\" class=\"headerlink\" title=\"DHCP 协议\"></a>DHCP 协议</h3><p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段 lP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。当接入局域网的时候，自动由这个 DHCP 服务器分配 IP，windows 用户可能知道网卡配置里面，有自动获取 IP 的功能，如果路由器提供 DHCP 服务，就会自动获取随机分配的 IP。路由器里可以开启这个服务。</p>\n<p>大致工作过程：</p>\n<p><img src=\"/img/notes/2020-3-27_1_13.png\" alt=\"DHCP数据发送过程\"></p>\n<h3 id=\"网际控制报文协议ICMP\"><a href=\"#网际控制报文协议ICMP\" class=\"headerlink\" title=\"网际控制报文协议ICMP\"></a>网际控制报文协议ICMP</h3><p>一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是 IP 协议并不提供可靠传输。如果丢包了，IP 协议并不能通知传输层是否丢包以及丢包的原因。</p>\n<p>所以我们就需要一种协议来完成这样的功能–<code>ICMP协议</code>。</p>\n<h4 id=\"ICMP-协议主要功能\"><a href=\"#ICMP-协议主要功能\" class=\"headerlink\" title=\"ICMP 协议主要功能\"></a>ICMP 协议主要功能</h4><ul>\n<li>确认 IP 报是否成功到达目标地址</li>\n<li>通知在发送过程中 IP 报被丢弃的原因，举一个例子：</li>\n</ul>\n<p><img src=\"/img/notes/2020-3-27_1_14.png\" alt=\"ICMP应答报文\"></p>\n<p>主机 H2 收到主机 H1 的一个<code>UDP报</code>，结果 H2 发现这个报里的端口没有被监听，这时候就回复给 H2 一个<code>ICMP应答报文</code>，意思是这个<code>UDP数据报</code>无法交给应用进程，只能丢弃了。</p>\n<p>以下是 4 种常见的 ICMP 差错报告报文：</p>\n<p><img src=\"/img/notes/2020-3-27_1_15.png\" alt=\"ICMP 差错报告报文\"></p>\n<p>我们常用的<code>PING</code>命令借助<code>ICMP协议</code>，探测主机是否能找到目的主机。</p>\n<h3 id=\"网络设备路由器简介\"><a href=\"#网络设备路由器简介\" class=\"headerlink\" title=\"网络设备路由器简介\"></a>网络设备路由器简介</h3><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发和分组。</p>\n<p>如下图所示，分别有转发和分组功能的说明。</p>\n<p><img src=\"/img/notes/2020-3-27_1_16.png\" alt=\"路由器功能\"></p>\n<p>接着，我们看一下路由器输入端口做了哪些事情：</p>\n<p><img src=\"/img/notes/2020-3-27_1_17.png\" alt=\"路由器输入端口\"></p>\n<ul>\n<li><p>首先，物理层是傻瓜层，传输<code>比特流</code>，我们把物理层的比特流还原成<code>数据链路层</code>的<code>数据帧</code>，然后把<code>数据链路层</code>的<code>数据报</code>脱去，成为<code>网络层数据报</code>，交给路由器。这时候就要判断一下这个数据报是什么类型的了。</p>\n</li>\n<li><p>如果它是路由器之间，交换路由信息的分组，就会把这个数据报交付给如上上图所示的，路由选择处理机，进行处理和计算。如果是数据分组，就会放到一个队列里面，排队等候，然后选择一个合适的输出端口输出。</p>\n</li>\n</ul>\n<p>最后我们看一下路由器输出端口做了哪些事情：</p>\n<p><img src=\"/img/notes/2020-3-27_1_18.png\" alt=\"路由器输出端口\"></p>\n<p>从上图可以看到，输出端口是做的输入端口的逆过程，将网络层的数据报转换为链路层的数据帧，最后转为物理层的比特流。</p>\n<blockquote>\n<p>输入和输出端口需要注意的是，它们都有一个缓冲队列，比如输入数据的速度太快，输出数据速度慢，为了平衡输入输出速度，就用缓冲队列把数据缓冲下来，一个一个慢慢的处理，但缓冲队列也有限度，超出这个限度，缓冲队列容纳不下，包就会被丢掉。</p>\n</blockquote>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><p>传输层是只有计算机才有的层次，主要提供是进程间<code>逻辑通信</code> + <code>可靠传输</code>或者<code>不可靠</code>的功能。比如 QQ 视频聊天，这就是不同计算机之间，进程间的通信。</p>\n<p>这里简单说一下<code>可靠传输协议TCP</code> + <code>不可靠传输协议UDP</code></p>\n<blockquote>\n<p>TCP 面向连接，可靠，不提供广播和多播，而且时间延迟比较大，适用于大文件传输。 UDP 无连接，收到的报也不确认，但时间延迟小，适用于小文件。</p>\n</blockquote>\n<h3 id=\"端口号有什么用\"><a href=\"#端口号有什么用\" class=\"headerlink\" title=\"端口号有什么用\"></a>端口号有什么用</h3><p>端口号可以用来标识同一个主机上通信的不同应用程序（就是哪个应用程序在使用这个端口）。</p>\n<p>那为什么一个端口只能分配给一个应用程序，不能是多个呢？</p>\n<p>如果服务器有两个应用程序 A，B，分别启动了 A 服务和 B 服务，它们监听同一个端口，那有数据来的时候，服务器无法判断这个数据到底是给 A，还是给 B。</p>\n<h3 id=\"用户数据报协议-UDP\"><a href=\"#用户数据报协议-UDP\" class=\"headerlink\" title=\"用户数据报协议 UDP\"></a>用户数据报协议 UDP</h3><p>UDP 协议是参考模型中一种<code>无连接</code>的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>\n<h4 id=\"UDP-协议的特点\"><a href=\"#UDP-协议的特点\" class=\"headerlink\" title=\"UDP 协议的特点\"></a>UDP 协议的特点</h4><ul>\n<li>UDP 是<code>无连接</code>的，减少开销和发送数据之前的时间延迟。<code>TCP</code>的<code>三次握手和四次挥手</code>，这个是需要时间花销的，但是 UDP 没有这部分花销。</li>\n<li>UDP 使用最<code>大努力交付</code>，即不保证可靠交付。那谁来保证可靠的交付呢？是由 UDP 的上一层协议，应用层来保证。</li>\n<li>UDP 是<code>面向报文</code>的，适合一次性传输少量数据的网络应用。什么意思呢，如下图，UDP 这层，把应用层的全部内容作为自己的数据报部分，在 IP 层也只是加了一个 IP 首部，我们知道，在以太网，链路层上的数据如果超过 1500 字节，就会分片，所以网络层发现上面传输层给了太大的数据就会分片，加上 UDP 是不可靠的协议，这就加大了 UDP 的不可靠性，容易丢失，所以 UDP 适合数据量少的。</li>\n</ul>\n<p><img src=\"/img/notes/2020-3-27_1_19.png\" alt=\"Alt text\"></p>\n<ul>\n<li>UDP <code>没有拥塞控制</code>，适合很多实时应用。也就是说如果网络堵塞，UDP 不管那么多，照样按照自己的速率发数据，那有些人就会说，这协议是不是有点坑 B，路都堵上了，还发死劲发数据呢，但是反过来看，这也是 UDP 的优点，它允许丢包，如果你的网络情况还不错，UDP 就非常适合实时应用，比如视频会议。</li>\n<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>\n<li>UDP <code>首部较小</code>，只有 8 字节，而 TCP 由 20 字节。这也是减少网络传输开销的一方面。</li>\n</ul>\n<h4 id=\"DUP-首部\"><a href=\"#DUP-首部\" class=\"headerlink\" title=\"DUP 首部\"></a>DUP 首部</h4><p><img src=\"/img/notes/2020-3-27_1_20.png\" alt=\"Alt text\"></p>\n<ul>\n<li>16 位端口号占了 2B，也就是 16 位，说明端口号的范围是<code>0 - 65535</code>。源端口号可以没有，因为不希望收到对方的回应，可以写全 0，目的端口是一定要有的。</li>\n<li>16 位 UDP 长度是指<code>首部+数据的长度</code>，比如数据 2B，首部固定是 8B，那么 UDP 长度就是 2+8 = 10B</li>\n<li>16 位 UDP 校验和，是用来校验<code>首部和数据有错误</code>，如果有错就丢弃掉。比如说目的主机找不到对应的端口号，就会给发送方返回一个 ICMP，<code>端口不可达</code>的差错报文。</li>\n</ul>\n<h3 id=\"传输控制协议-TCP\"><a href=\"#传输控制协议-TCP\" class=\"headerlink\" title=\"传输控制协议 TCP\"></a>传输控制协议 TCP</h3><p>TCP 协议简单来说是一种位于传输层的，面向连接的、可靠的、基于字节流的传输层通信协议。</p>\n<h4 id=\"TCP-协议的特点\"><a href=\"#TCP-协议的特点\" class=\"headerlink\" title=\"TCP 协议的特点\"></a>TCP 协议的特点</h4><ul>\n<li>TCP 是<code>面向连接</code>的传输层协议。比如说 TCP 的三次握手，四次分手，针对的都是连接。</li>\n<li>每一条 TCP 连接<code>只能有两个端点</code>，每一条 TCP 连接是点对点的。也就是说 TCP 是不同计算机之间的进程的通信。</li>\n<li>TCP 提供<code>可靠交付</code>的服务，无差错，不丢失，不重复，按序到达。总结一下就是，<code>可靠有序，不丢不重</code>。</li>\n<li>TCP 提供<code>全双工通信</code>。全双工指的是连接双方可以同时收发数据。在收发两端都有发送缓存和接收缓存，发送缓存就是一个准备发送的队列，接收缓存是一个准备接收的队列。</li>\n<li>TCP <code>面向字节流</code>。如下图。</li>\n</ul>\n<p><img src=\"/img/notes/2020-3-27_1_21.png\" alt=\"Alt text\"></p>\n<p>图中的 1，2，3，4…..数据块，每一个表示一个字节。TCP 将应用层的数据变为了这样的字节进行发送，比如 node 中的 buffer 就是字节流。</p>\n<h4 id=\"TCP-首部\"><a href=\"#TCP-首部\" class=\"headerlink\" title=\"TCP 首部\"></a>TCP 首部</h4><p>如下图所示，我们看一下比较重要的一些首部字段，这里我们介绍<code>固定的20字节</code>的 TCP 首部。</p>\n<p><img src=\"/img/notes/2020-3-27_1_22.png\" alt=\"Alt text\"></p>\n<ul>\n<li><p>源端口和目的端口分别是指发送方应用程序的端口和目的方应用程序的端口号。</p>\n</li>\n<li><p>序号是指在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，本字段表示<code>本报文段所发送数据的第一个字节的序号</code>。</p>\n</li>\n<li><p>确认号是指<code>期望收到对方下一个报文段的第一个数据字节的序号</code> 。若确认号为 N，则证明到需要 N-1 为止所有的数据都已经正确收到。</p>\n</li>\n<li><p>数据偏移指的是 TCP 报文段的数据起始距离 TCP 报文段的起始处有多远。</p>\n</li>\n<li><p>6 个控制位介绍：</p>\n<table>\n<thead>\n<tr>\n<th>控制位</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ACK</td>\n<td>置 1 时表示确认号合法，为 0 的时候表示数据段不包含确认信息，确认号被忽略</td>\n</tr>\n<tr>\n<td>PSH</td>\n<td>置 1 时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送</td>\n</tr>\n<tr>\n<td>RST</td>\n<td>置 1 时重建连接。如果接收到 RST 位时候，通常发生了某些错</td>\n</tr>\n<tr>\n<td>SYN</td>\n<td>置 1 时用来发起一个连接</td>\n</tr>\n<tr>\n<td>FIN</td>\n<td>置 1 时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了</td>\n</tr>\n<tr>\n<td>URG</td>\n<td>紧急指针，告诉接收 TCP 模块紧要指针域指着紧要数据</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"TCP-建立连接\"><a href=\"#TCP-建立连接\" class=\"headerlink\" title=\"TCP 建立连接\"></a>TCP 建立连接</h4><p>如下图所示：</p>\n<p><img src=\"/img/notes/2020-3-27_1_23.png\" alt=\"Alt text\"></p>\n<ol>\n<li>首先客户端要发送一个数据报告诉服务器要建立连接，根据上面了解到的控制位信息，建立连接需要把<code>SYN置为1</code>，同时选择一个初始序号<code>seq</code>，是随机产生的。TCP 规定，<code>SYN=1</code>的报文段不能携带数据，但要消耗一个序号。</li>\n<li>然后服务器收到该数据报后，会为该 TCP 连接分配缓存和变量，缓存指的是一个字节流队列。（发送方和接收方都有这个队列，而且如果双方需要互相通信，那么双方都会有发送缓存和接收缓存），接着会返回一个确认报文，其中 <code>SYN 控制位置为 1</code>，意思是允许建立连接，<code>ACK 也置为1</code>，确认收到了发送方的报，并且会设一个 seq ，也为一个随机数。小写 ack 是确认号，也就是接下来希望发送方要发的数据从哪开始, <code>ack=x+1</code>。</li>\n<li>最后，客户端需要给服务器端返回一个确认，此时 SYN 控制位变为 0，意思这不是建立连接的请求了，要正式发数据了，ACK 是确认码，意思是收到了服务器的确认请求了。</li>\n</ol>\n<p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据报。</p>\n<h4 id=\"TCP-释放连接\"><a href=\"#TCP-释放连接\" class=\"headerlink\" title=\"TCP 释放连接\"></a>TCP 释放连接</h4><p>如下图所示：</p>\n<p><img src=\"/img/notes/2020-3-27_1_24.png\" alt=\"Alt text\"></p>\n<ul>\n<li>客户端发起请求，请求断开链接。<code>FIN=1，seq=u</code>。u 是之前传送过的数据的最后一个字节的序号+1。FIN：用来释放一个链接，当<code>FIN=1</code>的时候，表明此报文的发送方已经完成了数据的发送，没有新的数据要传送，并要求释放链接。客户端等着服务器返回确认。FIN 报文段即使不携带数据，也消耗掉一个序号。</li>\n<li>服务器收到客户端的请求断开链接的报文之后，返回确认信息。<code>ACK=1，seq=v，ack=u+1</code>。这个时候，客户端不能给服务器发送信息报文，只能接收。但是服务器要是还有信息要传给服务器，仍然能传送。</li>\n<li>当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。<code>FIN=1，ACK=1，ack=u+1，seq=w</code>。这里的 w，跟上面的 v 是一个意思，为什么不都是 v 呢，因为这一步和上一步中间可能还在发数据呢，所以 seq 这个数据发送的字节流序号可能要变。</li>\n<li>客户端接收到<code>FIN=1</code>的报文之后，返回确认报文，<code>ACK=1，seq=u+1，ack=w+1</code>。发送完毕之后，客户端进入等待状态，等待两个时间周期。关闭。</li>\n</ul>\n<p>为什么最后还要等待两个时间周期呢？</p>\n<p><img src=\"/img/notes/2020-3-27_1_25.png\" alt=\"Alt text\"></p>\n<h4 id=\"相关问题\"><a href=\"#相关问题\" class=\"headerlink\" title=\"相关问题\"></a>相关问题</h4><p>1、三次是最小的安全次数，可以保证通信的双方都具有发送消息和接收响应的能力，发送方和接收方始终同步序号，可以实现可靠传输。</p>\n<p><img src=\"/img/notes/2020-3-27_1_26.png\" alt=\"Alt text\"></p>\n<p>2、如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>\n<p><code>TCP保活计时器</code> 每次客户端请求服务器会重置计时器，当<code>2小时之内</code>没收到客户端任何数据时，会每隔<code>75s</code>向客户端发一个探测报文，若接连发送<code>10</code>个，客户端都没有反应，则认为客户端故障，关闭连接。</p>\n<p>3、什么是 SYN 洪泛攻击？</p>\n<p>SYN 洪泛攻击就是利用 TCP 协议的特性（三次握手）。攻击者发送 TCP 的 SYN，SYN 是 TCP 三次握手中第一个数据报，而当服务器返回 ACK 后，该攻击者就不对其进行再确认，那这个 TCP 连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复发送 ACK 给攻击者。这样更加会浪费服务器资源。攻击者就对服务器发送大量的这种 TCP 连接，由于每一个连接都无法完成三次握手，所以就在服务器上，这些 TCP 连接会因为挂起状态而消耗 CPU 和内存，最后服务器可能死机。</p>\n<p>4、序号为什么要随机？</p>\n<p>增加安全性，为了避免被第三方猜测到，从而被第三方伪造的 RST 报文 Reset。</p>\n<p>5、三次握手的第一次可以携带数据吗？为何？</p>\n<p>不可以，三次握手还没有完成。而且这样会放大<code>SYN FLOOD</code>（SYN 洪泛）攻击。<br>如果攻击者伪造了成千上万的握手报文，携带了 1K+ 字节的数据，而接收方会开辟大量的缓存来容纳这些巨大数据，内存会很容易耗尽，从而拒绝服务。</p>\n<p>6、三次握手的第三次可以携带数据吗？为何？</p>\n<p>第三次握手，此时客户端已经处于<code>ESTABLISHED</code>状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。</p>\n<h4 id=\"TCP-如何实现可靠传输\"><a href=\"#TCP-如何实现可靠传输\" class=\"headerlink\" title=\"TCP 如何实现可靠传输\"></a>TCP 如何实现可靠传输</h4><p>主要通过以下四种方式实现可靠传输机制：</p>\n<ul>\n<li>校验。伪首部是为了增加 TCP 校验和的检错能力：通过伪首部的目的 IP 地址来检查 TCP 报文是否收错了、通过伪首部的传输层协议号来检查传输层协议是否选对了。需要注意的是，伪首部实际上是不存在的，只是用来验证 TCP 报文是否出错。</li>\n<li>序号。之前我们提到 TCP 是面向字节流的，比如第一个字节就是序号 1，第二个字节就是序号 2。 而在 TCP 报文格式介绍的时候，有一个序号字段，这个指的是一个报文段第一个字节的序号。报文段就是你每个数据包。有了序号，就能保证数据是有序的传入应用层。</li>\n<li>确认。发送方在收到接收方的确认报 之后，才继续发送剩下的数据。</li>\n<li>重传。TCP 的发送方在规定的时间内没有收到确认就要重传已发送的报文段（超时重传）。重传时间是动态改变的，依据的是 RTTS（加权平均往返时间）。</li>\n</ul>\n<h4 id=\"TCP-的流量控制\"><a href=\"#TCP-的流量控制\" class=\"headerlink\" title=\"TCP 的流量控制\"></a>TCP 的流量控制</h4><p>比如发送方发送速度非常快，接收方接收速度特别慢，这样就会发生严重的丢包现象。</p>\n<p>TCP 通过滑动窗口的机制来实现流量控制。简单来说如下：</p>\n<ul>\n<li>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。</li>\n<li>当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</li>\n</ul>\n<h4 id=\"TCP-的拥塞控制\"><a href=\"#TCP-的拥塞控制\" class=\"headerlink\" title=\"TCP 的拥塞控制\"></a>TCP 的拥塞控制</h4><ul>\n<li>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</li>\n<li>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</li>\n<li>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</li>\n</ul>\n<p>为了便于讨论，做如下假设：</p>\n<ul>\n<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>\n<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>\n</ul>\n<p>慢开始与拥塞避免：</p>\n<ul>\n<li>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li>\n<li>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</li>\n</ul>\n<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>\n<p>快重传与快恢复：</p>\n<ul>\n<li>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</li>\n<li>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</li>\n<li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</li>\n<li>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</li>\n</ul>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><h3 id=\"应用层作用\"><a href=\"#应用层作用\" class=\"headerlink\" title=\"应用层作用\"></a>应用层作用</h3><p>应用层对应用程序的通信提供服务。</p>\n<ul>\n<li>区分是发送报文还是接收报文</li>\n<li>定义报文类型的语法，比如某字段的意思，例如 http 中 content-type 字段是什么意思。</li>\n<li>最后就是进程如何，什么时候把传输层的数据交给应用层。</li>\n</ul>\n<p>一些比较重要的应用层协议如下图：</p>\n<p><img src=\"/img/notes/2020-3-27_1_27.png\" alt=\"Alt text\"></p>\n<h3 id=\"应用层常见的模型\"><a href=\"#应用层常见的模型\" class=\"headerlink\" title=\"应用层常见的模型\"></a>应用层常见的模型</h3><p>第一种是客户端/服务器模型，也就是 C/S 架构。比如电子邮件、web 都是。</p>\n<p><img src=\"/img/notes/2020-3-27_1_28.png\" alt=\"Alt text\"></p>\n<p>第二种是 P2P 模型，每个主机既可以提供服务，也可以请求服务。比如迅雷下载也是使用 P2P 技术的。</p>\n<p><img src=\"/img/notes/2020-3-27_1_29.png\" alt=\"Alt text\"></p>\n<h3 id=\"短链接和长链接\"><a href=\"#短链接和长链接\" class=\"headerlink\" title=\"短链接和长链接\"></a>短链接和长链接</h3><p>TCP 连接有两种工作方式：短连接方式（Short-Live Connection）和长连接方式（Long-Live Connection）。</p>\n<p>短连接方式：</p>\n<p>当客户端有请求时，会建立一个 TCP 连接，接收到服务器响应后，就断开连接。下次有请求时，再建立连接，收到响应后，再断开。如此循环。这种方式主要有两个缺点：</p>\n<ul>\n<li>建立 TCP 连接需要 3 次“握手”，拆除 TCP 连接需要 4 次“挥手”，这就需要 7 个数据报。如果请求和响应各占 1 个数据报，那么一次短连接的交互过程，有效的传输仅占 2/9，这个利用率太低了。</li>\n<li>主动断开 TCP 连接的一端，TCP 状态机会进入<code>TIME_WAIT</code>状态。如果频繁地使用短连接方式，就有可能使客户端的机器产生大量的处于<code>TIME_WAIT</code>状态 TCP 连接。</li>\n</ul>\n<p>长连接方式：<br>客户端和服务器建立 TCP 连接后，会一直使用这条连接进行数据交互，直到没有数据传输或异常断开。在空闲期间，通常会使用<code>Keep-Alive</code>保持链路不断开。目前长连接方式应用范围比较广泛。</p>\n<h4 id=\"持久连接\"><a href=\"#持久连接\" class=\"headerlink\" title=\"持久连接\"></a>持久连接</h4><p><code>Keep-Alive</code>是<code>http/1.1</code>增加的。 在没有<code>Keep-Alive</code>之前，HTTP 请求都是短连接，就是说每一次请求都要建立连接，请求完成后马上关闭连接，也就是我们上面说的三次握手和四次挥手过程，每次请求都要建立连接带来了资源的浪费，为了提高请求效率，于是有了<code>Keep-Alive</code>。</p>\n<p><code>Keep—Alive</code>允许在一定时间内，同一个域名多次请求数据，只建立一次 HTTP 连接，其他请求可以复用这个连接通道，以达到提高请求效率的目的。</p>\n<p>持久连接使得多数请求以<code>管状化</code>方式成为可能。以前发送请求后需要等待并收到响应，才能发送下一个请求。管状化技术出现后，不用等待响应也可直接发送下一个请求。</p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>DNS 就是将域名转化为 IP，比如 <code>www.qq.com</code>，这是域名，可以是网络报需要对方 IP 地址，域名是不能加入网络报报头的，所以就需要去找一个服务器问，qq 的域名对应的 IP 是多少。</p>\n<p>大概的通信过程如下：</p>\n<ol>\n<li>用户主机上运行着<code>DNS</code>的客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端了</li>\n<li>浏览器将接收到的 url 中抽取出域名字段，就是访问的主机名，比如 <code>http://www.baidu.com/</code> , 并将这个主机名传送给 DNS 应用的客户端</li>\n<li>DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式 DNS 集群的工作）</li>\n<li>该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址</li>\n<li>一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接</li>\n</ol>\n<h3 id=\"万维网和-HTTP-协议\"><a href=\"#万维网和-HTTP-协议\" class=\"headerlink\" title=\"万维网和 HTTP 协议\"></a>万维网和 HTTP 协议</h3><p>万维网 www 是一个大规模的、联机式的信息存储所，是无数个网络站点和网页的集合。<code>互联网包含因特网，因特网包含万维网</code>。</p>\n<ul>\n<li><code>互联网internet</code>。凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分，国际标准的互联网写法是 internet，字母 i 一定要小写！</li>\n<li><code>因特网Internet</code>。而因特网是互联网中的一种，它可不是仅有两台机器组成的网络，而是由上千万台设备组成的网络（该网络具备很大的规模）。因特网使用 TCP/IP 协议让不同的设备可以彼此通信。但使用 TCP/IP 协议的网络并不一定是因特网，一个局域网也可以使用 TCP/IP 协议。</li>\n<li>因特网是基于 TCP/IP 协议实现的，TCP/IP 协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如 FTP、SMTP、HTTP。所以，因特网提供的服务一般包括有：www（万维网）服务、电子邮件服务（outlook）、远程登录（QQ）服务、文件传输（FTP）服务、网络电话等等。</li>\n<li><code>万维网</code>。只要应用层使用的是 HTTP 协议，就称为万维网(World Wide Web)。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是 HTTP 协议在交流。</li>\n</ul>\n<p>万维网使用统一资源定位符 URL 作为标识符来访问资源。</p>\n<p>URL 的格式如下：</p>\n<p><img src=\"/img/notes/2020-3-27_1_30.png\" alt=\"Alt text\"></p>\n<p>用户通过点击超链接获取资源，这些资源通过超文本传输协议（HTTP）传送给使用者。</p>\n<p>HTTP 协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</p>\n<p><img src=\"/img/notes/2020-3-27_1_31.png\" alt=\"Alt text\"></p>\n<h3 id=\"HTTP-常用状态码\"><a href=\"#HTTP-常用状态码\" class=\"headerlink\" title=\"HTTP 常用状态码\"></a>HTTP 常用状态码</h3><ul>\n<li><code>200 OK</code>表示从客户端发来的请求被正常处理了。</li>\n<li><code>204 No Content</code>表示服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回实体的主体。比如<code>OPTIONS</code>请求。</li>\n<li><code>206 Partial Content</code>表示客户端进行了范围请求，而服务器成功执行了这部分请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li>\n<li><code>301 Moved Permanently</code>永久重定向。表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n<li><code>302 Found</code>临时性重定向。表示请求的资源已被分配了新的 URI，希望用户本次能使用新的 URI 访问。</li>\n<li><code>303 See Other</code>表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。<code>303</code>和<code>302</code>有着相同的功能，但<code>303</code>明确表示客户端应该用<code>GET</code>的方法获取资源。</li>\n<li><code>304 Not Modified</code>表示客户端发送附带条件（GET 方法的请求报文中包含 If-Match, If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since 中的任一首部）的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回<code>304</code>。<code>304</code>返回时，不包含任何响应的主体部分。</li>\n<li><code>307 Temporary Redirect</code>临时重定向。<code>307</code>会遵照浏览器标准，不会从<code>POST</code>变成<code>GET</code>。</li>\n<li><code>400 Bad Request</code>表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。浏览器会像<code>200</code>一样对待该状态码。</li>\n<li><code>401 Unauthorized</code>表示发送的请求需要有通过 HTTP 认证的认证信息。</li>\n<li><code>403 Forbidden</code>表示对请求资源的访问被服务器拒绝了。</li>\n<li><code>404 Not Found</code>表明服务器上无法找到请求的资源。</li>\n<li><code>500 Internal Server Error</code>表明服务器端在执行请求时发生了错误。</li>\n<li><code>503 Service Unavailable</code>表明服务器暂时处于超负载或在进行停机维护，现在无法处理请求。</li>\n</ul>\n<h3 id=\"HTTP-缺点\"><a href=\"#HTTP-缺点\" class=\"headerlink\" title=\"HTTP 缺点\"></a>HTTP 缺点</h3><ul>\n<li>通信使用明文（不加密），内容可能会被窃听</li>\n<li>不会验证通信方的身份，因此可能会遭遇伪装</li>\n<li>无法保证报文的完整性，请求或响应的内容被篡改也无法知道</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><p>HTTPS = HTTP + 加密 + 身份验证 + 数据完整性保护</p>\n<p>HTTPS 和 HTTP 区别：</p>\n<ul>\n<li>HTTP 使用明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议</li>\n<li>HTTP 不会验证通信方的身份，HTTPS 会通过数字证书来验证身份</li>\n<li>HTTPS 可以保证数据的完整性，防止传输内容被中间人冒充或篡改</li>\n<li>除以上外，HTTP 和 HTTPS 使用的端口也不同，前者使用 80 端口，后者使用 443 端口</li>\n</ul>\n<h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h3><p>相关概念：</p>\n<ul>\n<li>帧： HTTP/2 数据通信的最小单位。每个帧都包含帧首部，其中会标识当前帧所属的流。</li>\n<li>消息： 指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。 、</li>\n<li>流： 存在于连接中的虚拟通道。流可以承接双向消息，每个流都有一个唯一的整数 id。</li>\n<li>连接： 与 HTTP/1 相同，都是指对应的 TCP 连接。</li>\n</ul>\n<p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。而 HTTP/2 将请求和响应数据分隔成为更小的帧，并对他们采用二进制编码。</p>\n<p>相比 HTTP/1 的优化：</p>\n<ul>\n<li>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 HTTP/1）</li>\n<li>允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 HTTP/1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li>\n<li>二进制分帧：HTTP/2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li>\n<li>首部压缩</li>\n<li>服务器端推送</li>\n</ul>\n<p>HTTP/2 中，同域名下的所有请求都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，消息由一个或多个帧组成。多个帧之间可以乱序发送，然后根据帧首部的流标识可以重新组装。</p>\n<h3 id=\"WebSocket-协议\"><a href=\"#WebSocket-协议\" class=\"headerlink\" title=\"WebSocket 协议\"></a>WebSocket 协议</h3><p>主要特点：</p>\n<ul>\n<li>推送功能</li>\n<li>减少通信量</li>\n</ul>\n<p>握手-请求</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">Upgrade: websocket<br>Connection: Upgrade<br></code></pre></td></tr></table></figure>\n\n<p>握手-响应</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">HTTP/1.1 101 Switching Protocols<br>Upgrade: websocket<br>Connection: Upgrade<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在地址栏里输入一个-URL-到这个页面呈现出来，中间会发生什么？\"><a href=\"#在地址栏里输入一个-URL-到这个页面呈现出来，中间会发生什么？\" class=\"headerlink\" title=\"在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？\"></a>在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？</h3><ol>\n<li><p>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 HTTP 协议就按照 Web 方式来处理。</p>\n</li>\n<li><p>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法。</p>\n</li>\n<li><p>然后去找到这个 URL 对应的 IP 地址,为了寻找这个 IP 地址，浏览器首先会查找：浏览器缓存 -&gt; 操作系统缓存 -&gt; 本地 host 文件 -&gt; 路由器缓存 -&gt; DNS 服务器。</p>\n<p> <code>DNS 负载均衡</code>： 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用 DNS 负载均衡技术，它的原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址,在应答 DNS 查询时,DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>\n</li>\n<li><p>拿到域名对应的 IP 地址之后，浏览器根据这个 IP 地址以及相应的端口号会向服务器发起 TCP 的连接请求。</p>\n</li>\n<li><p>发送 HTTP 请求。</p>\n</li>\n<li><p>服务器处理请求。</p>\n<p> 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过 HTTP 协议访问某网站应用服务器，而是先请求到 Nginx，Nginx 再请求应用服务器，然后将结果返回给客户端，这里 Nginx 的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>\n</li>\n<li><p>服务器返回一个 HTTP 响应。</p>\n<blockquote>\n<p>使用<a href=\"/2021/05/14/RESTful-API/\">缓存</a></p>\n</blockquote>\n</li>\n<li><p>浏览器解析渲染页面。</p>\n<p> 浏览器是一个边解析边渲染的过程。首先浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和 repain(重绘)。DOM 节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为 repain。页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。</p>\n<blockquote>\n<p><a href=\"./%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3.md#%E9%87%8D%E7%BB%98repain%E5%92%8C%E9%87%8D%E6%8E%92(%E5%9B%9E%E6%B5%81)reflow%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95\">重绘 repain 和重排(回流)reflow 以及优化方法</a></p>\n</blockquote>\n<p> 当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。因为 JS 有可能会修改 DOM，最为经典的 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的根本原因。所以我明平时的代码中，js 是放在 html 文档末尾的。</p>\n<p> JS 的解析是由浏览器中的 JS 解析引擎完成的。JS 是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。</p>\n<p> JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p>\n</li>\n<li><p>连接结束<br> ​<br> 现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p>\n<p>按分布范围，计算机网络里有<code>局域网LAN</code>和<code>广域网WAN</code>, 其中局域网的代表以太网，以及这两种网络最重要的区分点，局域网基于<code>广播技术</code>，广域网基于<code>分组交换</code>技术。</p>\n<h3 id=\"网络的网络\"><a href=\"#网络的网络\" class=\"headerlink\" title=\"网络的网络\"></a>网络的网络</h3><p>网络把主机连接起来，而互连网<code>internet</code>是把多种不同的网络连接起来，因此互连网是网络的网络。而英特网<code>Internet</code>是全球范围的互连网。</p>\n<h3 id=\"ISP\"><a href=\"#ISP\" class=\"headerlink\" title=\"ISP\"></a>ISP</h3><div class=\"note note-primary\">\n            <p>ISP (Internet service provider) 互联网服务提供商</p>\n          </div>\n\n<p><code>ISP</code>可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向<code>ISP</code>缴纳一定的费用就可以接入互联网。</p>\n<p>目前的互联网是一种多层次<code>ISP</code>结构，<code>ISP</code>根据覆盖面积的大小分为第一层<code>ISP</code>、区域<code>ISP</code>和接入<code>ISP</code>。互联网交换点 IXP 允许两个<code>ISP</code>直接相连而不用经过第三个<code>ISP</code>。</p>\n<h3 id=\"主机之间的通信方式\"><a href=\"#主机之间的通信方式\" class=\"headerlink\" title=\"主机之间的通信方式\"></a>主机之间的通信方式</h3><ul>\n<li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li>\n<li>对等（P2P）：不区分客户和服务器。</li>\n</ul>\n<h3 id=\"电路交换与分组交换\"><a href=\"#电路交换与分组交换\" class=\"headerlink\" title=\"电路交换与分组交换\"></a>电路交换与分组交换</h3><ul>\n<li><p>电路交换</p>\n<p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>\n</li>\n<li><p>分组交换</p>\n<p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>\n</li>\n</ul>\n<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>\n<h3 id=\"衡量计算机网络的性能的指标\"><a href=\"#衡量计算机网络的性能的指标\" class=\"headerlink\" title=\"衡量计算机网络的性能的指标\"></a>衡量计算机网络的性能的指标</h3><h4 id=\"速率\"><a href=\"#速率\" class=\"headerlink\" title=\"速率\"></a>速率</h4><p>速率就是数据传输（数据是指 0 和 1）的速率，比如用迅雷下载，1 兆每秒，来衡量目前数据传输的快慢。它是计算机网络中最重要的一个性能指标。</p>\n<h4 id=\"带宽\"><a href=\"#带宽\" class=\"headerlink\" title=\"带宽\"></a>带宽</h4><p>在计算机网络中，网络带宽是指在单位时间（一般指的是 1 秒钟）内能传输的数据量，比如说你家的电信网络是 100 兆比特，意思是，一秒内最大的传输速率是 100 兆比特。</p>\n<h4 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h4><p>吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。</p>\n<div class=\"note note-primary\">\n            <p>由此可知带宽说的是最大值速率，吞吐量说的是某时刻速率。但吞吐量不能超过最大速率</p>\n          </div>\n\n<h4 id=\"时延\"><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h4><p>时延是指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。单位是 s。 时延分以下几种：</p>\n<ul>\n<li>排队时延：分组在经过网络传输时，要经过很多的<code>路由器</code>。但分组在进入路由器后要先在输入队列中<code>排队等待</code>处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发，这就产生了<code>排队时延</code>。排队时延的长短往往却决于网络当时的通信量，当网络的通信量很大时会发生排队溢出，是<code>分组丢失</code>。</li>\n<li>处理时延：<code>路由器</code>或<code>主机</code>在收到数据报时，要花费一定时间进行处理，例如<code>分析数据报的首部</code>、进行<code>首部差错检验</code>，<code>查找路由表</code>为数据报选定准发接口，这就产生了处理时延。</li>\n<li>发送时延：主机或路由器传输数据帧所需要的时间。</li>\n<li>传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</li>\n</ul>\n<div class=\"note note-primary\">\n            <p>总时延 = 排队时延 + 处理时延 + 发送时延 + 传播时延</p>\n          </div>\n\n<h4 id=\"往返时间（RTT）\"><a href=\"#往返时间（RTT）\" class=\"headerlink\" title=\"往返时间（RTT）\"></a>往返时间（RTT）</h4><p>在计算机网络中，往返时间也是一个重要的性能指标，它表示从发送方发送数据开始，到发送方收到来自接收方的确认（接受方收到数据后便立即发送确认）总共经历的时间。</p>\n<h4 id=\"时延带宽积\"><a href=\"#时延带宽积\" class=\"headerlink\" title=\"时延带宽积\"></a>时延带宽积</h4><p>是指传播时延乘以带宽。</p>\n<h3 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h3><p><img src=\"/img/notes/2020-3-27_1_32.png\" alt=\"计算机网络体系结构\"></p>\n<h4 id=\"五层协议\"><a href=\"#五层协议\" class=\"headerlink\" title=\"五层协议\"></a>五层协议</h4><ul>\n<li>应用层：为特定应用程序提供数据传输服务，例如<code>HTTP</code>、<code>DNS</code>等协议。数据单位为报文。</li>\n<li>传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议<code>TCP</code>，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 <code>UDP</code>，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。<code>TCP</code>主要提供完整性服务，<code>UDP</code>主要提供及时性服务。</li>\n<li>网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>\n<li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>\n<li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>\n</ul>\n<h4 id=\"OSI\"><a href=\"#OSI\" class=\"headerlink\" title=\"OSI\"></a>OSI</h4><div class=\"note note-primary\">\n            <p>OSI (Open System Interconnection Model)</p>\n          </div>\n\n<p>如下图所示，1、2、3 层主要是<code>物理链路</code>组成的，比如<code>光纤</code>，<code>路由器</code>，<code>集线器</code>，主要负责的是<code>数据通信</code>。5、6、7 层是<code>软件控制</code>的，比如<code>HTTP</code>协议，是一种软件层面控制的协议，主要负责处理传输来的<code>数据</code>。</p>\n<p><img src=\"/img/notes/2020-3-27_1_1.png\" alt=\"OSI\"></p>\n<p>其中表示层和会话层用途如下:</p>\n<ul>\n<li><p>表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>\n</li>\n<li><p>会话层：建立及管理会话。</p>\n</li>\n</ul>\n<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>\n<h4 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h4><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>\n<p><code>TCP/IP</code>体系结构不严格遵循<code>OSI</code>分层概念，应用层可能会直接使用IP层或者网络接口层。</p>\n<h4 id=\"数据在各层之间的传递过程\"><a href=\"#数据在各层之间的传递过程\" class=\"headerlink\" title=\"数据在各层之间的传递过程\"></a>数据在各层之间的传递过程</h4><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>\n<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><h3 id=\"物理层作用\"><a href=\"#物理层作用\" class=\"headerlink\" title=\"物理层作用\"></a>物理层作用</h3><p>对于物理层，有人会说，这不就是网线吗，比如家里连接路由器的网线，电线杆上的光纤？其实不然，物理层更多的是规定一种标准，他并不管物理介质具体是什么，比如电线杆上是光纤还是双绞线，只要你能按物理层规定的标准传输数据就行。</p>\n<div class=\"note note-primary\">\n            <p>物理层是规定传输媒体接口的标准</p>\n          </div>\n\n<h3 id=\"通信方式\"><a href=\"#通信方式\" class=\"headerlink\" title=\"通信方式\"></a>通信方式</h3><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>\n<ul>\n<li>单工通信：单向传输。</li>\n<li>半双工通信：双向交替传输。是指允许数据在两个方向上传输，但是在某一时刻只允许数据在一个方向上传输。</li>\n<li>全双工通信：双向同时传输。</li>\n</ul>\n<h3 id=\"光纤宽带上网的传输数据形式\"><a href=\"#光纤宽带上网的传输数据形式\" class=\"headerlink\" title=\"光纤宽带上网的传输数据形式\"></a>光纤宽带上网的传输数据形式</h3><ul>\n<li>首先计算机网卡传输出来的数据是<code>电信号</code>，光纤传输的是<code>光脉冲</code>信号，有光脉冲表示<code>1</code>，无光脉冲表示<code>0</code>。</li>\n<li>而可见光的频率大约是<code>10的8次方MHz</code>，因此光纤通信系统的带宽远远大于其它各种传输媒体的带宽</li>\n<li>所以我们计算机传输数据需要先把<code>电信号</code>转为<code>光信号</code>，然后<code>光信号</code>快到服务器的时候，再把<code>光信号</code>转为<code>电信号</code>。</li>\n</ul>\n<h3 id=\"物理层设备中继器\"><a href=\"#物理层设备中继器\" class=\"headerlink\" title=\"物理层设备中继器\"></a>物理层设备中继器</h3><p>为什么需要中继器呢？因为再线路上传输的信号功率会<code>逐渐衰减</code>，衰减到一定程度时将造成<code>信号失真</code>，因此会导致接收错误。中继器可以对信号进行<code>再生</code>和<code>还原</code>，增加信号的传输距离。</p>\n<p>需要注意的是，中继器两端连接不同的网段，而不是子网。</p>\n<h2 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h2><h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><ul>\n<li>封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。封装的网络数据报，在链路层就叫<code>数据帧</code>。</li>\n<li>透明传输：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</li>\n<li>差错控制：在文件送到 B 公司小秘书手里的时候，快递包上写着 5 个文件，秘书一看只有 3 个文件，就会让物理层重新发送有没有送到的文件。目前数据链路层广泛使用了<code>CRC循环冗余检验</code>来检查比特差错。</li>\n<li>差错纠正：链路层知道 1，2，3，4，5 个文件，丢失的两个文件到底是哪两个，并且能通过重新发送没有的文件来纠正。</li>\n<li>流量控制：比如说发送方发送速度特别快，接收方接收速度特别慢，会造成传输出错。</li>\n</ul>\n<p>这里需要注意的是，传输层 TCP 也有流量控制功能，区别在于 TCP 是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）流量控制的方法有滑动窗口协议，以及选择重传协议。</p>\n<h3 id=\"通信分类\"><a href=\"#通信分类\" class=\"headerlink\" title=\"通信分类\"></a>通信分类</h3><h4 id=\"广播信道\"><a href=\"#广播信道\" class=\"headerlink\" title=\"广播信道\"></a>广播信道</h4><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p>\n<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>\n<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>\n<h4 id=\"点对点信道\"><a href=\"#点对点信道\" class=\"headerlink\" title=\"点对点信道\"></a>点对点信道</h4><p>一对一通信。</p>\n<p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p>\n<h3 id=\"CSMA-CD-协议\"><a href=\"#CSMA-CD-协议\" class=\"headerlink\" title=\"CSMA/CD 协议\"></a>CSMA/CD 协议</h3><p><code>CSMA/CD</code>表示载波监听多点接入/碰撞检测。</p>\n<ul>\n<li>多点接入：说明这是总线型网络（半双工），许多主机以多点的方式连接到总线上。</li>\n<li>载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>\n<li>碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>\n</ul>\n<h3 id=\"PPP-协议\"><a href=\"#PPP-协议\" class=\"headerlink\" title=\"PPP 协议\"></a>PPP 协议</h3><p>互联网用户通常需要连接到某个<code>ISP</code>之后才能接入到互联网，<code>PPP</code>协议是用户计算机和<code>ISP</code>进行通信时所使用的数据链路层协议。</p>\n<p>PPP 的帧格式：</p>\n<ul>\n<li>F 字段为帧的定界符</li>\n<li>A 和 C 字段暂时没有意义</li>\n<li>FCS 字段是使用 CRC 的检验序列</li>\n<li>信息部分的长度不超过 1500</li>\n</ul>\n<h3 id=\"MAC地址\"><a href=\"#MAC地址\" class=\"headerlink\" title=\"MAC地址\"></a>MAC地址</h3><p><code>MAC地址</code>是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>\n<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>\n<h3 id=\"局域网\"><a href=\"#局域网\" class=\"headerlink\" title=\"局域网\"></a>局域网</h3><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>\n<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>\n<p>可以按照网络拓扑结构对局域网进行分类：</p>\n<p><img src=\"/img/notes/2020-3-27_1_33.png\" alt=\"局域网拓扑结构\"></p>\n<h3 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h3><p>以太网是一种<code>局域网</code>技术，其规定了<code>访问控制方法</code>、<code>传输控制协议</code>、<code>网络拓扑结构</code>、<code>传输速率</code>等，完成数据链路层和物理层的一些内容，它采用一种称作<code>CSMA/CD</code>的媒体接入方法，另外的一些局域网技术，比如无线局域网等。</p>\n<h4 id=\"以太网的帧格式\"><a href=\"#以太网的帧格式\" class=\"headerlink\" title=\"以太网的帧格式\"></a>以太网的帧格式</h4><p><img src=\"/img/notes/2020-3-27_1_2.png\" alt=\"以太网的帧格式\"></p>\n<ul>\n<li>其中<code>目的地址</code>和<code>源地址</code>指的是<code>MAC地址</code>，即设备的物理地址。<code>MAC地址</code>用于标示网卡，每个网卡都具有唯一的<code>MAC地址</code>。</li>\n<li>当在同一个局域网中，主机<code>A</code>需要给主机<code>B</code>发送消息时，主机<code>A</code>将以太网帧发出，此时局域网中所有主机均可收到这个桢，主机中的网卡接收到以太网桢后，会将目的<code>MAC地址</code>和自己的<code>MAC地址</code>进行比较,如果不相同就会丢弃，如果相同则会接收，此时则<code>Ｂ</code>主机就收到了<code>Ａ</code>的消息。</li>\n<li>其最后面是<code>CRC循环冗余码</code>，用于差错控制，即检验帧的正确性。</li>\n<li>在以太网协议中，目的地址分为三种<code>单播地址</code>、<code>广播地址</code>、<code>多播地址</code>，其中<code>单播地址</code>如上面<code>Ａ</code>给<code>Ｂ</code>主机发送，其接收者为一个，并且其目的地址的最高字节的低位为<code>0</code>。</li>\n</ul>\n<h4 id=\"以太网的特点\"><a href=\"#以太网的特点\" class=\"headerlink\" title=\"以太网的特点\"></a>以太网的特点</h4><ul>\n<li>无连接。发送方和接收方不建立连接。</li>\n<li>不可靠。接收方不向发送方进行确认，差错帧直接丢弃。</li>\n</ul>\n<h4 id=\"以太网的拓扑结构\"><a href=\"#以太网的拓扑结构\" class=\"headerlink\" title=\"以太网的拓扑结构\"></a>以太网的拓扑结构</h4><p>跟以太网相关的拓扑结构有<code>星型</code>和<code>总线型</code>。</p>\n<p>互联网初期，以太网的<code>总线型拓扑</code>比较普遍。随着总线型以太网上的站点数目增多,<code>可靠性也会随之下降</code>,而随着大规模集成电路以及专门芯片的发展,使得<code>星型以太网变得便宜又可靠</code>。</p>\n<p>需要注意的是，以太网虽然物理上是<code>星型拓扑</code>，但逻辑上是<code>总线型</code>。</p>\n<h3 id=\"网卡\"><a href=\"#网卡\" class=\"headerlink\" title=\"网卡\"></a>网卡</h3><p>计算机传出的数据，经过网卡，就会变为<code>以太网的帧</code>，还会完成一些<code>链路管理</code>（CSMA/CD 的实现），以及<code>编码</code>和<code>译码</code>。</p>\n<h3 id=\"无线局域网\"><a href=\"#无线局域网\" class=\"headerlink\" title=\"无线局域网\"></a>无线局域网</h3><p>无线局域网 WLAN 是利用无线电波、激光和红外线等无线通信技术来构建的局域网。</p>\n<h3 id=\"链路层的设备\"><a href=\"#链路层的设备\" class=\"headerlink\" title=\"链路层的设备\"></a>链路层的设备</h3><h4 id=\"网桥\"><a href=\"#网桥\" class=\"headerlink\" title=\"网桥\"></a>网桥</h4><p>网桥根据<code>MAC帧</code>的目的地址进行转发和过滤。当网桥收到一个帧时，并不会向所有接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个口，或者是把它丢弃。</p>\n<p>这里需要注意的是，网桥连接的是不同的网段.</p>\n<h4 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h4><p>谈到交换机，就不得不提两个概念，<code>冲突域</code>和<code>广播域</code></p>\n<ul>\n<li>冲突域： 是指同一时间只能由一台设备发送信息的范围。</li>\n<li>广播域：如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为广播域</li>\n</ul>\n<p>也就是说，广播域可以跨网段，而冲突域只是发生的同一个网段。</p>\n<p>举个例子，公司里大家的电脑一般都是连接到交换机上，因为交换机可以隔离冲突域，冲突域的最大问题在于，同一时间只能有一台机器传输数据，公司那么多人，如果这样的话，传输数据速度太慢了。然后交换机再连接到路由器上，首先路由器能隔离广播域，其次不经过路由器，你的数据链路层上的包没办法进入到互联网里面去，路由器是网络层的设备。</p>\n<p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>\n<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>\n<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>\n<p><img src=\"/img/notes/2020-3-27_1_3.png\" alt=\"交换机交换表\"></p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><p>网络层主要任务是将<code>分组</code>从一台主机移动到另一台主机，从而提供了<code>主机到主机的通信服务</code>和各种形式的<code>进程到进程的通信</code>。</p>\n<p>分组：大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发动，这种小块就称作分组。</p>\n<h3 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h3><p>当<code>主机H1</code>要向另一<code>主机H2</code>发送数据（报文）时，首先将数据划分成若干个等长的分组，然后将这些分组一个接一个地发往里与<code>H1</code>相联的<code>路由A</code>,当<code>A</code>接到分组后，先放入缓冲区，再按一定的路由算法确定该分组下一步将发注哪个结点，如此一个结点一个结点传递，直到最终目的<code>H2</code>。</p>\n<p>这一段话比较啰嗦，简单来说分组就是<code>分数据块</code>，同时还具有<code>无需建立连接</code>，存储转发（存储转发是指以太网交换机的控制器先将输入端口到来的数据报缓存起来，先检查数据报是否正确，并过滤掉冲突包错误），<code>动态分配路线</code>（交换设备会根据网络状况选择不同的路线，比如路由器）的优点。</p>\n<h3 id=\"数据报\"><a href=\"#数据报\" class=\"headerlink\" title=\"数据报\"></a>数据报</h3><p>数据报是通过网络传输的<code>数据的基本单元</code>，包含一个<code>报头（header）</code>和<code>数据</code>本身。说白了，就是带地址的数据，比如你的写了一句微信”你好”，这串文字本上加上源地址，目的地址，就是数据报。</p>\n<h3 id=\"IP-数据报格式\"><a href=\"#IP-数据报格式\" class=\"headerlink\" title=\"IP 数据报格式\"></a>IP 数据报格式</h3><p><img src=\"/img/notes/2020-3-27_1_5.png\" alt=\"IP数据报格式\"></p>\n<ul>\n<li>首部的<strong>固定部分</strong>是<code>20字节</code>，共 <code>20 * 8 = 160</code> 比特（1 字节=8 比特）。</li>\n<li><strong>版本</strong>：占4位，有 4（IPv4）和 6（IPv6）两个值。</li>\n<li><strong>首部长度</strong>：<code>单位是 4B</code>，最小为 5，因为首部至少 20 字节，所以 4 * 5 就是 20 字节。</li>\n<li><strong>区分服务</strong> ：用来获得更好的服务，一般情况下不使用。</li>\n<li><strong>总长度</strong>：首部长度+数据部分长度。</li>\n<li><strong>标识</strong>： 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>\n<li><strong>片偏移</strong> ：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>\n<li><strong>生存时间</strong>：<code>TTL</code>，它告诉网络，数据报在网络中的时间是否太长而应被丢弃。以路由器跳数为单位，每经过一个路由器减一，变成 0 就丢弃。</li>\n<li><strong>协议</strong>：是指数据部分用的什么协议，我们只需要知道<code>TCP</code>协议用<code>6</code>表示，<code>UDP</code>协议用<code>17</code>表示即可。</li>\n<li><strong>首部校验和</strong>：这个字段只检验数据报的首部，不包括数据部分，因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>\n<li><strong>目的地址</strong>和<strong>源地址</strong>都是<code>IP地址</code>，目的地址是通过<code>DNS</code>查询得来的。</li>\n</ul>\n<h3 id=\"IP-分片\"><a href=\"#IP-分片\" class=\"headerlink\" title=\"IP 分片\"></a>IP 分片</h3><p>为什么需要分片：链路层数据帧封装的数据大小是有限制的，以太网的 MTU（MTU 是指一种通信协议的某一层上面所能通过的最大数据报大小）是 1500 字节。</p>\n<p>在 IP 数据报上，标识了分片的数据的字段：</p>\n<p><img src=\"/img/notes/2020-3-27_1_7.png\" alt=\"IP数据报格式\"></p>\n<ul>\n<li><strong>标识</strong></li>\n<li><strong>标志</strong>：占 3 位，但只有两位有意义，第一个位叫<code>MF(More Fragment)</code>，MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。中间的一位记为<code>DF(Don’t Fragment)</code>，意思是“不能分片”。只有当 DF=0 时才允许分片。</li>\n<li><strong>片偏移</strong>：较长的分组在分片后，某片在原分组中的相对位置。</li>\n</ul>\n<p><img src=\"/img/notes/2020-3-27_1_34.png\" alt=\"数据报的分片举例\"></p>\n<h3 id=\"IP-地址分类\"><a href=\"#IP-地址分类\" class=\"headerlink\" title=\"IP 地址分类\"></a>IP 地址分类</h3><p><img src=\"/img/notes/2020-3-27_1_6.png\" alt=\"IP地址分类\"></p>\n<p>其中<code>127.0.0.0~127.255.255.255</code>用于环回测试。</p>\n<p>有一部分叫<code>私有IP地址</code>，是不能拿到网络上跟别的计算机通信的。只能是局域网自己内部用。比如说有：</p>\n<p><img src=\"/img/notes/2020-3-27_1_8.png\" alt=\"私有IP地址\"></p>\n<p>可以看到，C 类私有地址就是<code>192.168</code>网段，每个局域网都可以有这些私有 IP。</p>\n<p>还有一些<code>特殊地址</code>，需要了解：</p>\n<p><img src=\"/img/notes/2020-3-27_1_9.png\" alt=\"特殊地址\"></p>\n<p>注意，这里的全 1 是指，IPV4 地址由 4 个字节组成，每一个字节是 8 位，8 位全一就是十进制的 255, 即<code>255.255.255.255</code>。</p>\n<ul>\n<li>第一行，全一，代表是<code>255.255.255.255</code>，在本网络的目的地址写这个的话，就会内网广播。</li>\n<li>第二行，网络号特定值，主机号是全 0，比如，<code>192.169.10.1</code>，这是 c 类网络，所以网络号是<code>192.169.10</code>，主机号是 1，当主机号全 0 时，就是 0，表示<code>192.169.10.0</code>这个网段。</li>\n<li>第三行，还是<code>192.169.10.1</code>这个 c 类地址，主机号都是 1，也就是 8 个 1，代表 255，所以 <code>192.169.10.255</code>表示本网段的广播地址。</li>\n<li>第四行，127 作为网络号，主机号非全 0 或 1，比如说<code>127.0.0.1</code>代表本机，称为环回地址。</li>\n</ul>\n<p>IPV4 中，<code>0.0.0.0</code>地址被用于表示一个无效的，未知的或者不可用的目标。在服务器中，<code>0.0.0.0</code>指的是本机上的所有 IPV4 地址，如果一个主机有两个 IP 地址，<code>192.168.1.1</code>和<code>10.1.2.1</code>，并且该主机上的一个服务监听的地址是<code>0.0.0.0</code>，那么通过两个 IP 地址都能够访问该服务。</p>\n<h3 id=\"网络地址转换-NAT\"><a href=\"#网络地址转换-NAT\" class=\"headerlink\" title=\"网络地址转换(NAT)\"></a>网络地址转换(NAT)</h3><p>在 IP 地址分类里面，我们知道私有 IP 地址是不能跟外网交互的，在小公司大多数计算机的地址都是<code>192.168</code>网段，都是私有 IP 地址，它是怎么跟外网交互数据的呢，这里就引出来一个知识点叫<code>网络地址转换NAT</code>。</p>\n<p><img src=\"/img/notes/2020-3-27_1_10.png\" alt=\"网络地址转换NAT\"></p>\n<p>如上图所示，<code>192.168.0.3</code>，<code>192.168.0.4</code>都是私有网段上的，它们无法跟外网通信，这个时候由于路由器安装了 NAT 软件，就可以将自己的 IP 地址，即路由器的 IP 地址<code>172.38.1.5</code>作为内网的代理，去访问外网，外网返回来的数据，经过路由转换，转换成内网的<code>192.168</code>网段的私有地址。</p>\n<h3 id=\"子网划分和子网掩码\"><a href=\"#子网划分和子网掩码\" class=\"headerlink\" title=\"子网划分和子网掩码\"></a>子网划分和子网掩码</h3><p>划分子网的方式是从网络的主机号借用若干位作为子网号，主机号也就相应减少了同样的位数。</p>\n<p><img src=\"/img/notes/2020-3-27_1_11.png\" alt=\"子网划分\"></p>\n<p>当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。</p>\n<p>我们将<code>145.13.0.0</code>这个网段划分了三个子网，其中一个是<code>145.13.3.0</code>，一个是<code>145.13.21.0</code>，问题来了，如果一个数据报来了，数据报要交给的 IP 地址是<code>145.13.3.10</code>，我们怎么知道给哪个子网呢？</p>\n<p>方法是将数据报的目的地址，跟子网的子网掩码相与预算（二进制与预算规则是，1 跟 1 得 1，其它为 0），也就是目的地址<code>145.13.3.10</code>跟子网<code>145.13.3.0</code>的子网掩码<code>255.255.255.0</code>的与预算，得到的结果是<code>145.13.3.0</code>，所以发送到的子网就是<code>145.13.3.0</code>。</p>\n<h3 id=\"地址解析协议ARP\"><a href=\"#地址解析协议ARP\" class=\"headerlink\" title=\"地址解析协议ARP\"></a>地址解析协议ARP</h3><p>以太网的帧的格式：</p>\n<p><img src=\"/img/notes/2020-3-27_1_2.png\" alt=\"以太网的帧格式\"></p>\n<p>上图有一个<code>源地址</code>和<code>目的地址</code>，这两个地址都是指的<code>MAC地址</code>，<code>MAC地址</code>是什么呢？简单说来就是两台相邻的路由器 A 和 B，A 怎么把数据传给 B 呢，它总要知道 B 的物理地址吧，物理地址就像门牌号一样，我要知道你住在哪里，才能把数据送过去吧？首先你肯定知道自己的<code>MAC地址</code>是多少，因为在网卡上有，问题在于，别人的<code>MAC地址</code>是多少？<code>ARP协议</code>就是来帮你找<code>MAC地址</code>的。</p>\n<h4 id=\"ARP协议的过程\"><a href=\"#ARP协议的过程\" class=\"headerlink\" title=\"ARP协议的过程\"></a>ARP协议的过程</h4><p><img src=\"/img/notes/2020-3-27_1_12.png\" alt=\"ARP协议的过程\"></p>\n<ol>\n<li>每台主机都会在自己的<code>ARP缓冲区</code>中建立一个<code>ARP列表</code>，以表示 <code>IP地址</code>和<code>MAC地址</code>的映射关系</li>\n<li>当源主机需要将一个数据报要发送到目的主机时，会首先检查自己<code>ARP列表</code>中是否存在该<code>IP地址</code>对应的 <code>MAC地址</code></li>\n<li>如果有，就直接将数据报发送到这个<code>MAC地址</code>；如果没有，就向本地网段发起一个 <code>ARP</code>请求的广播报，查询此目的主机对应的<code>MAC地址</code></li>\n<li>此<code>ARP</code>请求数据报里包括源主机的<code>IP地址</code>、<code>硬件地址</code>、以及<code>目的主机的IP地址</code>。网络中所有的主机收到这个<code>ARP请求</code>后，会检查数据报中的目的<code>IP</code>是否和自己的<code>IP地址</code>一致</li>\n<li>如果不相同就忽略此数据报；如果相同，该主机首先将发送端的<code>MAC地址</code>和 <code>IP地址</code>添加到自己的<code>ARP列表</code>中</li>\n<li>如果<code>ARP表</code>中已经存在该<code>IP</code>的信息，则将其覆盖，然后给源主机发送一个 <code>ARP响应数据报</code>，告诉对方自己是它需要查找的<code>MAC地址</code></li>\n<li>源主机收到这个<code>ARP响应数据报</code>后，将得到的目的主机的<code>IP地址</code>和<code>MAC地址</code>添加到自己的<code>ARP列表</code>中，并利用此信息开始数据的传输</li>\n<li>如果源主机一直没有收到<code>ARP响应数据报</code>，表示<code>ARP查询失败</code>。</li>\n</ol>\n<h3 id=\"DHCP-协议\"><a href=\"#DHCP-协议\" class=\"headerlink\" title=\"DHCP 协议\"></a>DHCP 协议</h3><p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段 lP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。当接入局域网的时候，自动由这个 DHCP 服务器分配 IP，windows 用户可能知道网卡配置里面，有自动获取 IP 的功能，如果路由器提供 DHCP 服务，就会自动获取随机分配的 IP。路由器里可以开启这个服务。</p>\n<p>大致工作过程：</p>\n<p><img src=\"/img/notes/2020-3-27_1_13.png\" alt=\"DHCP数据发送过程\"></p>\n<h3 id=\"网际控制报文协议ICMP\"><a href=\"#网际控制报文协议ICMP\" class=\"headerlink\" title=\"网际控制报文协议ICMP\"></a>网际控制报文协议ICMP</h3><p>一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是 IP 协议并不提供可靠传输。如果丢包了，IP 协议并不能通知传输层是否丢包以及丢包的原因。</p>\n<p>所以我们就需要一种协议来完成这样的功能–<code>ICMP协议</code>。</p>\n<h4 id=\"ICMP-协议主要功能\"><a href=\"#ICMP-协议主要功能\" class=\"headerlink\" title=\"ICMP 协议主要功能\"></a>ICMP 协议主要功能</h4><ul>\n<li>确认 IP 报是否成功到达目标地址</li>\n<li>通知在发送过程中 IP 报被丢弃的原因，举一个例子：</li>\n</ul>\n<p><img src=\"/img/notes/2020-3-27_1_14.png\" alt=\"ICMP应答报文\"></p>\n<p>主机 H2 收到主机 H1 的一个<code>UDP报</code>，结果 H2 发现这个报里的端口没有被监听，这时候就回复给 H2 一个<code>ICMP应答报文</code>，意思是这个<code>UDP数据报</code>无法交给应用进程，只能丢弃了。</p>\n<p>以下是 4 种常见的 ICMP 差错报告报文：</p>\n<p><img src=\"/img/notes/2020-3-27_1_15.png\" alt=\"ICMP 差错报告报文\"></p>\n<p>我们常用的<code>PING</code>命令借助<code>ICMP协议</code>，探测主机是否能找到目的主机。</p>\n<h3 id=\"网络设备路由器简介\"><a href=\"#网络设备路由器简介\" class=\"headerlink\" title=\"网络设备路由器简介\"></a>网络设备路由器简介</h3><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发和分组。</p>\n<p>如下图所示，分别有转发和分组功能的说明。</p>\n<p><img src=\"/img/notes/2020-3-27_1_16.png\" alt=\"路由器功能\"></p>\n<p>接着，我们看一下路由器输入端口做了哪些事情：</p>\n<p><img src=\"/img/notes/2020-3-27_1_17.png\" alt=\"路由器输入端口\"></p>\n<ul>\n<li><p>首先，物理层是傻瓜层，传输<code>比特流</code>，我们把物理层的比特流还原成<code>数据链路层</code>的<code>数据帧</code>，然后把<code>数据链路层</code>的<code>数据报</code>脱去，成为<code>网络层数据报</code>，交给路由器。这时候就要判断一下这个数据报是什么类型的了。</p>\n</li>\n<li><p>如果它是路由器之间，交换路由信息的分组，就会把这个数据报交付给如上上图所示的，路由选择处理机，进行处理和计算。如果是数据分组，就会放到一个队列里面，排队等候，然后选择一个合适的输出端口输出。</p>\n</li>\n</ul>\n<p>最后我们看一下路由器输出端口做了哪些事情：</p>\n<p><img src=\"/img/notes/2020-3-27_1_18.png\" alt=\"路由器输出端口\"></p>\n<p>从上图可以看到，输出端口是做的输入端口的逆过程，将网络层的数据报转换为链路层的数据帧，最后转为物理层的比特流。</p>\n<blockquote>\n<p>输入和输出端口需要注意的是，它们都有一个缓冲队列，比如输入数据的速度太快，输出数据速度慢，为了平衡输入输出速度，就用缓冲队列把数据缓冲下来，一个一个慢慢的处理，但缓冲队列也有限度，超出这个限度，缓冲队列容纳不下，包就会被丢掉。</p>\n</blockquote>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><p>传输层是只有计算机才有的层次，主要提供是进程间<code>逻辑通信</code> + <code>可靠传输</code>或者<code>不可靠</code>的功能。比如 QQ 视频聊天，这就是不同计算机之间，进程间的通信。</p>\n<p>这里简单说一下<code>可靠传输协议TCP</code> + <code>不可靠传输协议UDP</code></p>\n<blockquote>\n<p>TCP 面向连接，可靠，不提供广播和多播，而且时间延迟比较大，适用于大文件传输。 UDP 无连接，收到的报也不确认，但时间延迟小，适用于小文件。</p>\n</blockquote>\n<h3 id=\"端口号有什么用\"><a href=\"#端口号有什么用\" class=\"headerlink\" title=\"端口号有什么用\"></a>端口号有什么用</h3><p>端口号可以用来标识同一个主机上通信的不同应用程序（就是哪个应用程序在使用这个端口）。</p>\n<p>那为什么一个端口只能分配给一个应用程序，不能是多个呢？</p>\n<p>如果服务器有两个应用程序 A，B，分别启动了 A 服务和 B 服务，它们监听同一个端口，那有数据来的时候，服务器无法判断这个数据到底是给 A，还是给 B。</p>\n<h3 id=\"用户数据报协议-UDP\"><a href=\"#用户数据报协议-UDP\" class=\"headerlink\" title=\"用户数据报协议 UDP\"></a>用户数据报协议 UDP</h3><p>UDP 协议是参考模型中一种<code>无连接</code>的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>\n<h4 id=\"UDP-协议的特点\"><a href=\"#UDP-协议的特点\" class=\"headerlink\" title=\"UDP 协议的特点\"></a>UDP 协议的特点</h4><ul>\n<li>UDP 是<code>无连接</code>的，减少开销和发送数据之前的时间延迟。<code>TCP</code>的<code>三次握手和四次挥手</code>，这个是需要时间花销的，但是 UDP 没有这部分花销。</li>\n<li>UDP 使用最<code>大努力交付</code>，即不保证可靠交付。那谁来保证可靠的交付呢？是由 UDP 的上一层协议，应用层来保证。</li>\n<li>UDP 是<code>面向报文</code>的，适合一次性传输少量数据的网络应用。什么意思呢，如下图，UDP 这层，把应用层的全部内容作为自己的数据报部分，在 IP 层也只是加了一个 IP 首部，我们知道，在以太网，链路层上的数据如果超过 1500 字节，就会分片，所以网络层发现上面传输层给了太大的数据就会分片，加上 UDP 是不可靠的协议，这就加大了 UDP 的不可靠性，容易丢失，所以 UDP 适合数据量少的。</li>\n</ul>\n<p><img src=\"/img/notes/2020-3-27_1_19.png\" alt=\"Alt text\"></p>\n<ul>\n<li>UDP <code>没有拥塞控制</code>，适合很多实时应用。也就是说如果网络堵塞，UDP 不管那么多，照样按照自己的速率发数据，那有些人就会说，这协议是不是有点坑 B，路都堵上了，还发死劲发数据呢，但是反过来看，这也是 UDP 的优点，它允许丢包，如果你的网络情况还不错，UDP 就非常适合实时应用，比如视频会议。</li>\n<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>\n<li>UDP <code>首部较小</code>，只有 8 字节，而 TCP 由 20 字节。这也是减少网络传输开销的一方面。</li>\n</ul>\n<h4 id=\"DUP-首部\"><a href=\"#DUP-首部\" class=\"headerlink\" title=\"DUP 首部\"></a>DUP 首部</h4><p><img src=\"/img/notes/2020-3-27_1_20.png\" alt=\"Alt text\"></p>\n<ul>\n<li>16 位端口号占了 2B，也就是 16 位，说明端口号的范围是<code>0 - 65535</code>。源端口号可以没有，因为不希望收到对方的回应，可以写全 0，目的端口是一定要有的。</li>\n<li>16 位 UDP 长度是指<code>首部+数据的长度</code>，比如数据 2B，首部固定是 8B，那么 UDP 长度就是 2+8 = 10B</li>\n<li>16 位 UDP 校验和，是用来校验<code>首部和数据有错误</code>，如果有错就丢弃掉。比如说目的主机找不到对应的端口号，就会给发送方返回一个 ICMP，<code>端口不可达</code>的差错报文。</li>\n</ul>\n<h3 id=\"传输控制协议-TCP\"><a href=\"#传输控制协议-TCP\" class=\"headerlink\" title=\"传输控制协议 TCP\"></a>传输控制协议 TCP</h3><p>TCP 协议简单来说是一种位于传输层的，面向连接的、可靠的、基于字节流的传输层通信协议。</p>\n<h4 id=\"TCP-协议的特点\"><a href=\"#TCP-协议的特点\" class=\"headerlink\" title=\"TCP 协议的特点\"></a>TCP 协议的特点</h4><ul>\n<li>TCP 是<code>面向连接</code>的传输层协议。比如说 TCP 的三次握手，四次分手，针对的都是连接。</li>\n<li>每一条 TCP 连接<code>只能有两个端点</code>，每一条 TCP 连接是点对点的。也就是说 TCP 是不同计算机之间的进程的通信。</li>\n<li>TCP 提供<code>可靠交付</code>的服务，无差错，不丢失，不重复，按序到达。总结一下就是，<code>可靠有序，不丢不重</code>。</li>\n<li>TCP 提供<code>全双工通信</code>。全双工指的是连接双方可以同时收发数据。在收发两端都有发送缓存和接收缓存，发送缓存就是一个准备发送的队列，接收缓存是一个准备接收的队列。</li>\n<li>TCP <code>面向字节流</code>。如下图。</li>\n</ul>\n<p><img src=\"/img/notes/2020-3-27_1_21.png\" alt=\"Alt text\"></p>\n<p>图中的 1，2，3，4…..数据块，每一个表示一个字节。TCP 将应用层的数据变为了这样的字节进行发送，比如 node 中的 buffer 就是字节流。</p>\n<h4 id=\"TCP-首部\"><a href=\"#TCP-首部\" class=\"headerlink\" title=\"TCP 首部\"></a>TCP 首部</h4><p>如下图所示，我们看一下比较重要的一些首部字段，这里我们介绍<code>固定的20字节</code>的 TCP 首部。</p>\n<p><img src=\"/img/notes/2020-3-27_1_22.png\" alt=\"Alt text\"></p>\n<ul>\n<li><p>源端口和目的端口分别是指发送方应用程序的端口和目的方应用程序的端口号。</p>\n</li>\n<li><p>序号是指在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，本字段表示<code>本报文段所发送数据的第一个字节的序号</code>。</p>\n</li>\n<li><p>确认号是指<code>期望收到对方下一个报文段的第一个数据字节的序号</code> 。若确认号为 N，则证明到需要 N-1 为止所有的数据都已经正确收到。</p>\n</li>\n<li><p>数据偏移指的是 TCP 报文段的数据起始距离 TCP 报文段的起始处有多远。</p>\n</li>\n<li><p>6 个控制位介绍：</p>\n<table>\n<thead>\n<tr>\n<th>控制位</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ACK</td>\n<td>置 1 时表示确认号合法，为 0 的时候表示数据段不包含确认信息，确认号被忽略</td>\n</tr>\n<tr>\n<td>PSH</td>\n<td>置 1 时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送</td>\n</tr>\n<tr>\n<td>RST</td>\n<td>置 1 时重建连接。如果接收到 RST 位时候，通常发生了某些错</td>\n</tr>\n<tr>\n<td>SYN</td>\n<td>置 1 时用来发起一个连接</td>\n</tr>\n<tr>\n<td>FIN</td>\n<td>置 1 时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了</td>\n</tr>\n<tr>\n<td>URG</td>\n<td>紧急指针，告诉接收 TCP 模块紧要指针域指着紧要数据</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"TCP-建立连接\"><a href=\"#TCP-建立连接\" class=\"headerlink\" title=\"TCP 建立连接\"></a>TCP 建立连接</h4><p>如下图所示：</p>\n<p><img src=\"/img/notes/2020-3-27_1_23.png\" alt=\"Alt text\"></p>\n<ol>\n<li>首先客户端要发送一个数据报告诉服务器要建立连接，根据上面了解到的控制位信息，建立连接需要把<code>SYN置为1</code>，同时选择一个初始序号<code>seq</code>，是随机产生的。TCP 规定，<code>SYN=1</code>的报文段不能携带数据，但要消耗一个序号。</li>\n<li>然后服务器收到该数据报后，会为该 TCP 连接分配缓存和变量，缓存指的是一个字节流队列。（发送方和接收方都有这个队列，而且如果双方需要互相通信，那么双方都会有发送缓存和接收缓存），接着会返回一个确认报文，其中 <code>SYN 控制位置为 1</code>，意思是允许建立连接，<code>ACK 也置为1</code>，确认收到了发送方的报，并且会设一个 seq ，也为一个随机数。小写 ack 是确认号，也就是接下来希望发送方要发的数据从哪开始, <code>ack=x+1</code>。</li>\n<li>最后，客户端需要给服务器端返回一个确认，此时 SYN 控制位变为 0，意思这不是建立连接的请求了，要正式发数据了，ACK 是确认码，意思是收到了服务器的确认请求了。</li>\n</ol>\n<p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据报。</p>\n<h4 id=\"TCP-释放连接\"><a href=\"#TCP-释放连接\" class=\"headerlink\" title=\"TCP 释放连接\"></a>TCP 释放连接</h4><p>如下图所示：</p>\n<p><img src=\"/img/notes/2020-3-27_1_24.png\" alt=\"Alt text\"></p>\n<ul>\n<li>客户端发起请求，请求断开链接。<code>FIN=1，seq=u</code>。u 是之前传送过的数据的最后一个字节的序号+1。FIN：用来释放一个链接，当<code>FIN=1</code>的时候，表明此报文的发送方已经完成了数据的发送，没有新的数据要传送，并要求释放链接。客户端等着服务器返回确认。FIN 报文段即使不携带数据，也消耗掉一个序号。</li>\n<li>服务器收到客户端的请求断开链接的报文之后，返回确认信息。<code>ACK=1，seq=v，ack=u+1</code>。这个时候，客户端不能给服务器发送信息报文，只能接收。但是服务器要是还有信息要传给服务器，仍然能传送。</li>\n<li>当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。<code>FIN=1，ACK=1，ack=u+1，seq=w</code>。这里的 w，跟上面的 v 是一个意思，为什么不都是 v 呢，因为这一步和上一步中间可能还在发数据呢，所以 seq 这个数据发送的字节流序号可能要变。</li>\n<li>客户端接收到<code>FIN=1</code>的报文之后，返回确认报文，<code>ACK=1，seq=u+1，ack=w+1</code>。发送完毕之后，客户端进入等待状态，等待两个时间周期。关闭。</li>\n</ul>\n<p>为什么最后还要等待两个时间周期呢？</p>\n<p><img src=\"/img/notes/2020-3-27_1_25.png\" alt=\"Alt text\"></p>\n<h4 id=\"相关问题\"><a href=\"#相关问题\" class=\"headerlink\" title=\"相关问题\"></a>相关问题</h4><p>1、三次是最小的安全次数，可以保证通信的双方都具有发送消息和接收响应的能力，发送方和接收方始终同步序号，可以实现可靠传输。</p>\n<p><img src=\"/img/notes/2020-3-27_1_26.png\" alt=\"Alt text\"></p>\n<p>2、如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>\n<p><code>TCP保活计时器</code> 每次客户端请求服务器会重置计时器，当<code>2小时之内</code>没收到客户端任何数据时，会每隔<code>75s</code>向客户端发一个探测报文，若接连发送<code>10</code>个，客户端都没有反应，则认为客户端故障，关闭连接。</p>\n<p>3、什么是 SYN 洪泛攻击？</p>\n<p>SYN 洪泛攻击就是利用 TCP 协议的特性（三次握手）。攻击者发送 TCP 的 SYN，SYN 是 TCP 三次握手中第一个数据报，而当服务器返回 ACK 后，该攻击者就不对其进行再确认，那这个 TCP 连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复发送 ACK 给攻击者。这样更加会浪费服务器资源。攻击者就对服务器发送大量的这种 TCP 连接，由于每一个连接都无法完成三次握手，所以就在服务器上，这些 TCP 连接会因为挂起状态而消耗 CPU 和内存，最后服务器可能死机。</p>\n<p>4、序号为什么要随机？</p>\n<p>增加安全性，为了避免被第三方猜测到，从而被第三方伪造的 RST 报文 Reset。</p>\n<p>5、三次握手的第一次可以携带数据吗？为何？</p>\n<p>不可以，三次握手还没有完成。而且这样会放大<code>SYN FLOOD</code>（SYN 洪泛）攻击。<br>如果攻击者伪造了成千上万的握手报文，携带了 1K+ 字节的数据，而接收方会开辟大量的缓存来容纳这些巨大数据，内存会很容易耗尽，从而拒绝服务。</p>\n<p>6、三次握手的第三次可以携带数据吗？为何？</p>\n<p>第三次握手，此时客户端已经处于<code>ESTABLISHED</code>状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。</p>\n<h4 id=\"TCP-如何实现可靠传输\"><a href=\"#TCP-如何实现可靠传输\" class=\"headerlink\" title=\"TCP 如何实现可靠传输\"></a>TCP 如何实现可靠传输</h4><p>主要通过以下四种方式实现可靠传输机制：</p>\n<ul>\n<li>校验。伪首部是为了增加 TCP 校验和的检错能力：通过伪首部的目的 IP 地址来检查 TCP 报文是否收错了、通过伪首部的传输层协议号来检查传输层协议是否选对了。需要注意的是，伪首部实际上是不存在的，只是用来验证 TCP 报文是否出错。</li>\n<li>序号。之前我们提到 TCP 是面向字节流的，比如第一个字节就是序号 1，第二个字节就是序号 2。 而在 TCP 报文格式介绍的时候，有一个序号字段，这个指的是一个报文段第一个字节的序号。报文段就是你每个数据包。有了序号，就能保证数据是有序的传入应用层。</li>\n<li>确认。发送方在收到接收方的确认报 之后，才继续发送剩下的数据。</li>\n<li>重传。TCP 的发送方在规定的时间内没有收到确认就要重传已发送的报文段（超时重传）。重传时间是动态改变的，依据的是 RTTS（加权平均往返时间）。</li>\n</ul>\n<h4 id=\"TCP-的流量控制\"><a href=\"#TCP-的流量控制\" class=\"headerlink\" title=\"TCP 的流量控制\"></a>TCP 的流量控制</h4><p>比如发送方发送速度非常快，接收方接收速度特别慢，这样就会发生严重的丢包现象。</p>\n<p>TCP 通过滑动窗口的机制来实现流量控制。简单来说如下：</p>\n<ul>\n<li>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。</li>\n<li>当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</li>\n</ul>\n<h4 id=\"TCP-的拥塞控制\"><a href=\"#TCP-的拥塞控制\" class=\"headerlink\" title=\"TCP 的拥塞控制\"></a>TCP 的拥塞控制</h4><ul>\n<li>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</li>\n<li>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</li>\n<li>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</li>\n</ul>\n<p>为了便于讨论，做如下假设：</p>\n<ul>\n<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>\n<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>\n</ul>\n<p>慢开始与拥塞避免：</p>\n<ul>\n<li>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li>\n<li>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</li>\n</ul>\n<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>\n<p>快重传与快恢复：</p>\n<ul>\n<li>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</li>\n<li>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</li>\n<li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</li>\n<li>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</li>\n</ul>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><h3 id=\"应用层作用\"><a href=\"#应用层作用\" class=\"headerlink\" title=\"应用层作用\"></a>应用层作用</h3><p>应用层对应用程序的通信提供服务。</p>\n<ul>\n<li>区分是发送报文还是接收报文</li>\n<li>定义报文类型的语法，比如某字段的意思，例如 http 中 content-type 字段是什么意思。</li>\n<li>最后就是进程如何，什么时候把传输层的数据交给应用层。</li>\n</ul>\n<p>一些比较重要的应用层协议如下图：</p>\n<p><img src=\"/img/notes/2020-3-27_1_27.png\" alt=\"Alt text\"></p>\n<h3 id=\"应用层常见的模型\"><a href=\"#应用层常见的模型\" class=\"headerlink\" title=\"应用层常见的模型\"></a>应用层常见的模型</h3><p>第一种是客户端/服务器模型，也就是 C/S 架构。比如电子邮件、web 都是。</p>\n<p><img src=\"/img/notes/2020-3-27_1_28.png\" alt=\"Alt text\"></p>\n<p>第二种是 P2P 模型，每个主机既可以提供服务，也可以请求服务。比如迅雷下载也是使用 P2P 技术的。</p>\n<p><img src=\"/img/notes/2020-3-27_1_29.png\" alt=\"Alt text\"></p>\n<h3 id=\"短链接和长链接\"><a href=\"#短链接和长链接\" class=\"headerlink\" title=\"短链接和长链接\"></a>短链接和长链接</h3><p>TCP 连接有两种工作方式：短连接方式（Short-Live Connection）和长连接方式（Long-Live Connection）。</p>\n<p>短连接方式：</p>\n<p>当客户端有请求时，会建立一个 TCP 连接，接收到服务器响应后，就断开连接。下次有请求时，再建立连接，收到响应后，再断开。如此循环。这种方式主要有两个缺点：</p>\n<ul>\n<li>建立 TCP 连接需要 3 次“握手”，拆除 TCP 连接需要 4 次“挥手”，这就需要 7 个数据报。如果请求和响应各占 1 个数据报，那么一次短连接的交互过程，有效的传输仅占 2/9，这个利用率太低了。</li>\n<li>主动断开 TCP 连接的一端，TCP 状态机会进入<code>TIME_WAIT</code>状态。如果频繁地使用短连接方式，就有可能使客户端的机器产生大量的处于<code>TIME_WAIT</code>状态 TCP 连接。</li>\n</ul>\n<p>长连接方式：<br>客户端和服务器建立 TCP 连接后，会一直使用这条连接进行数据交互，直到没有数据传输或异常断开。在空闲期间，通常会使用<code>Keep-Alive</code>保持链路不断开。目前长连接方式应用范围比较广泛。</p>\n<h4 id=\"持久连接\"><a href=\"#持久连接\" class=\"headerlink\" title=\"持久连接\"></a>持久连接</h4><p><code>Keep-Alive</code>是<code>http/1.1</code>增加的。 在没有<code>Keep-Alive</code>之前，HTTP 请求都是短连接，就是说每一次请求都要建立连接，请求完成后马上关闭连接，也就是我们上面说的三次握手和四次挥手过程，每次请求都要建立连接带来了资源的浪费，为了提高请求效率，于是有了<code>Keep-Alive</code>。</p>\n<p><code>Keep—Alive</code>允许在一定时间内，同一个域名多次请求数据，只建立一次 HTTP 连接，其他请求可以复用这个连接通道，以达到提高请求效率的目的。</p>\n<p>持久连接使得多数请求以<code>管状化</code>方式成为可能。以前发送请求后需要等待并收到响应，才能发送下一个请求。管状化技术出现后，不用等待响应也可直接发送下一个请求。</p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>DNS 就是将域名转化为 IP，比如 <code>www.qq.com</code>，这是域名，可以是网络报需要对方 IP 地址，域名是不能加入网络报报头的，所以就需要去找一个服务器问，qq 的域名对应的 IP 是多少。</p>\n<p>大概的通信过程如下：</p>\n<ol>\n<li>用户主机上运行着<code>DNS</code>的客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端了</li>\n<li>浏览器将接收到的 url 中抽取出域名字段，就是访问的主机名，比如 <code>http://www.baidu.com/</code> , 并将这个主机名传送给 DNS 应用的客户端</li>\n<li>DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式 DNS 集群的工作）</li>\n<li>该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址</li>\n<li>一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接</li>\n</ol>\n<h3 id=\"万维网和-HTTP-协议\"><a href=\"#万维网和-HTTP-协议\" class=\"headerlink\" title=\"万维网和 HTTP 协议\"></a>万维网和 HTTP 协议</h3><p>万维网 www 是一个大规模的、联机式的信息存储所，是无数个网络站点和网页的集合。<code>互联网包含因特网，因特网包含万维网</code>。</p>\n<ul>\n<li><code>互联网internet</code>。凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分，国际标准的互联网写法是 internet，字母 i 一定要小写！</li>\n<li><code>因特网Internet</code>。而因特网是互联网中的一种，它可不是仅有两台机器组成的网络，而是由上千万台设备组成的网络（该网络具备很大的规模）。因特网使用 TCP/IP 协议让不同的设备可以彼此通信。但使用 TCP/IP 协议的网络并不一定是因特网，一个局域网也可以使用 TCP/IP 协议。</li>\n<li>因特网是基于 TCP/IP 协议实现的，TCP/IP 协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如 FTP、SMTP、HTTP。所以，因特网提供的服务一般包括有：www（万维网）服务、电子邮件服务（outlook）、远程登录（QQ）服务、文件传输（FTP）服务、网络电话等等。</li>\n<li><code>万维网</code>。只要应用层使用的是 HTTP 协议，就称为万维网(World Wide Web)。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是 HTTP 协议在交流。</li>\n</ul>\n<p>万维网使用统一资源定位符 URL 作为标识符来访问资源。</p>\n<p>URL 的格式如下：</p>\n<p><img src=\"/img/notes/2020-3-27_1_30.png\" alt=\"Alt text\"></p>\n<p>用户通过点击超链接获取资源，这些资源通过超文本传输协议（HTTP）传送给使用者。</p>\n<p>HTTP 协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</p>\n<p><img src=\"/img/notes/2020-3-27_1_31.png\" alt=\"Alt text\"></p>\n<h3 id=\"HTTP-常用状态码\"><a href=\"#HTTP-常用状态码\" class=\"headerlink\" title=\"HTTP 常用状态码\"></a>HTTP 常用状态码</h3><ul>\n<li><code>200 OK</code>表示从客户端发来的请求被正常处理了。</li>\n<li><code>204 No Content</code>表示服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回实体的主体。比如<code>OPTIONS</code>请求。</li>\n<li><code>206 Partial Content</code>表示客户端进行了范围请求，而服务器成功执行了这部分请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li>\n<li><code>301 Moved Permanently</code>永久重定向。表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n<li><code>302 Found</code>临时性重定向。表示请求的资源已被分配了新的 URI，希望用户本次能使用新的 URI 访问。</li>\n<li><code>303 See Other</code>表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。<code>303</code>和<code>302</code>有着相同的功能，但<code>303</code>明确表示客户端应该用<code>GET</code>的方法获取资源。</li>\n<li><code>304 Not Modified</code>表示客户端发送附带条件（GET 方法的请求报文中包含 If-Match, If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since 中的任一首部）的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回<code>304</code>。<code>304</code>返回时，不包含任何响应的主体部分。</li>\n<li><code>307 Temporary Redirect</code>临时重定向。<code>307</code>会遵照浏览器标准，不会从<code>POST</code>变成<code>GET</code>。</li>\n<li><code>400 Bad Request</code>表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。浏览器会像<code>200</code>一样对待该状态码。</li>\n<li><code>401 Unauthorized</code>表示发送的请求需要有通过 HTTP 认证的认证信息。</li>\n<li><code>403 Forbidden</code>表示对请求资源的访问被服务器拒绝了。</li>\n<li><code>404 Not Found</code>表明服务器上无法找到请求的资源。</li>\n<li><code>500 Internal Server Error</code>表明服务器端在执行请求时发生了错误。</li>\n<li><code>503 Service Unavailable</code>表明服务器暂时处于超负载或在进行停机维护，现在无法处理请求。</li>\n</ul>\n<h3 id=\"HTTP-缺点\"><a href=\"#HTTP-缺点\" class=\"headerlink\" title=\"HTTP 缺点\"></a>HTTP 缺点</h3><ul>\n<li>通信使用明文（不加密），内容可能会被窃听</li>\n<li>不会验证通信方的身份，因此可能会遭遇伪装</li>\n<li>无法保证报文的完整性，请求或响应的内容被篡改也无法知道</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><p>HTTPS = HTTP + 加密 + 身份验证 + 数据完整性保护</p>\n<p>HTTPS 和 HTTP 区别：</p>\n<ul>\n<li>HTTP 使用明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议</li>\n<li>HTTP 不会验证通信方的身份，HTTPS 会通过数字证书来验证身份</li>\n<li>HTTPS 可以保证数据的完整性，防止传输内容被中间人冒充或篡改</li>\n<li>除以上外，HTTP 和 HTTPS 使用的端口也不同，前者使用 80 端口，后者使用 443 端口</li>\n</ul>\n<h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h3><p>相关概念：</p>\n<ul>\n<li>帧： HTTP/2 数据通信的最小单位。每个帧都包含帧首部，其中会标识当前帧所属的流。</li>\n<li>消息： 指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。 、</li>\n<li>流： 存在于连接中的虚拟通道。流可以承接双向消息，每个流都有一个唯一的整数 id。</li>\n<li>连接： 与 HTTP/1 相同，都是指对应的 TCP 连接。</li>\n</ul>\n<p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。而 HTTP/2 将请求和响应数据分隔成为更小的帧，并对他们采用二进制编码。</p>\n<p>相比 HTTP/1 的优化：</p>\n<ul>\n<li>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 HTTP/1）</li>\n<li>允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 HTTP/1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li>\n<li>二进制分帧：HTTP/2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li>\n<li>首部压缩</li>\n<li>服务器端推送</li>\n</ul>\n<p>HTTP/2 中，同域名下的所有请求都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，消息由一个或多个帧组成。多个帧之间可以乱序发送，然后根据帧首部的流标识可以重新组装。</p>\n<h3 id=\"WebSocket-协议\"><a href=\"#WebSocket-协议\" class=\"headerlink\" title=\"WebSocket 协议\"></a>WebSocket 协议</h3><p>主要特点：</p>\n<ul>\n<li>推送功能</li>\n<li>减少通信量</li>\n</ul>\n<p>握手-请求</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">Upgrade: websocket<br>Connection: Upgrade<br></code></pre></td></tr></table></figure>\n\n<p>握手-响应</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">HTTP/1.1 101 Switching Protocols<br>Upgrade: websocket<br>Connection: Upgrade<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"在地址栏里输入一个-URL-到这个页面呈现出来，中间会发生什么？\"><a href=\"#在地址栏里输入一个-URL-到这个页面呈现出来，中间会发生什么？\" class=\"headerlink\" title=\"在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？\"></a>在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？</h3><ol>\n<li><p>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 HTTP 协议就按照 Web 方式来处理。</p>\n</li>\n<li><p>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法。</p>\n</li>\n<li><p>然后去找到这个 URL 对应的 IP 地址,为了寻找这个 IP 地址，浏览器首先会查找：浏览器缓存 -&gt; 操作系统缓存 -&gt; 本地 host 文件 -&gt; 路由器缓存 -&gt; DNS 服务器。</p>\n<p> <code>DNS 负载均衡</code>： 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用 DNS 负载均衡技术，它的原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址,在应答 DNS 查询时,DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>\n</li>\n<li><p>拿到域名对应的 IP 地址之后，浏览器根据这个 IP 地址以及相应的端口号会向服务器发起 TCP 的连接请求。</p>\n</li>\n<li><p>发送 HTTP 请求。</p>\n</li>\n<li><p>服务器处理请求。</p>\n<p> 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过 HTTP 协议访问某网站应用服务器，而是先请求到 Nginx，Nginx 再请求应用服务器，然后将结果返回给客户端，这里 Nginx 的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>\n</li>\n<li><p>服务器返回一个 HTTP 响应。</p>\n<blockquote>\n<p>使用<a href=\"/2021/05/14/RESTful-API/\">缓存</a></p>\n</blockquote>\n</li>\n<li><p>浏览器解析渲染页面。</p>\n<p> 浏览器是一个边解析边渲染的过程。首先浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和 repain(重绘)。DOM 节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为 repain。页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。</p>\n<blockquote>\n<p><a href=\"./%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3.md#%E9%87%8D%E7%BB%98repain%E5%92%8C%E9%87%8D%E6%8E%92(%E5%9B%9E%E6%B5%81)reflow%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95\">重绘 repain 和重排(回流)reflow 以及优化方法</a></p>\n</blockquote>\n<p> 当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。因为 JS 有可能会修改 DOM，最为经典的 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的根本原因。所以我明平时的代码中，js 是放在 html 文档末尾的。</p>\n<p> JS 的解析是由浏览器中的 JS 解析引擎完成的。JS 是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。</p>\n<p> JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p>\n</li>\n<li><p>连接结束<br> ​<br> 现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭。</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckr90alny0001as7ih13yar63","tag_id":"ckr90alo00003as7i3fpocqmf","_id":"ckr90alo20006as7ics1625d1"},{"post_id":"ckr90alo00002as7ibakphdhc","tag_id":"ckr90alo10005as7iendngovv","_id":"ckr90alo20008as7i55kwhail"},{"post_id":"ckr90alo10004as7i7d0zdg8x","tag_id":"ckr90alo20007as7iez7ogvzt","_id":"ckr90alo20009as7iek5n3ptm"}],"Tag":[{"name":"Git","_id":"ckr90alo00003as7i3fpocqmf"},{"name":"RESTful API","_id":"ckr90alo10005as7iendngovv"},{"name":"计算机基础","_id":"ckr90alo20007as7iez7ogvzt"}]}}